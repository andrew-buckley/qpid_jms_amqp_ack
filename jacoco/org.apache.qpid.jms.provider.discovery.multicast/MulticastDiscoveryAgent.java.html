<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MulticastDiscoveryAgent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Discovery Library</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms.provider.discovery.multicast</a> &gt; <span class="el_source">MulticastDiscoveryAgent.java</span></div><h1>MulticastDiscoveryAgent.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms.provider.discovery.multicast;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.InterfaceAddress;
import java.net.MulticastSocket;
import java.net.NetworkInterface;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.qpid.jms.provider.discovery.DiscoveryAgent;
import org.apache.qpid.jms.provider.discovery.DiscoveryListener;
import org.apache.qpid.jms.provider.discovery.multicast.DiscoveryEvent.EventType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Discovery agent that listens on a multicast address for new Broker advisories.
 */
public class MulticastDiscoveryAgent implements DiscoveryAgent, Runnable {

    public static final String DEFAULT_DISCOVERY_URI_STRING = &quot;multicast://239.255.2.3:6155&quot;;
    public static final String DEFAULT_HOST_STR = &quot;default&quot;;
<span class="fc" id="L53">    public static final String DEFAULT_HOST_IP = System.getProperty(&quot;qpidjms.partition.discovery&quot;, &quot;239.255.2.3&quot;);</span>
    public static final int DEFAULT_PORT = 6155;

<span class="fc" id="L56">    private static final Logger LOG = LoggerFactory.getLogger(MulticastDiscoveryAgent.class);</span>
    private static final int BUFF_SIZE = 8192;
    private static final int DEFAULT_IDLE_TIME = 500;
    private static final int HEARTBEAT_MISS_BEFORE_DEATH = 10;

<span class="fc" id="L61">    private static final List&lt;String&gt; DEFAULT_EXCLUSIONS = new ArrayList&lt;String&gt;();</span>

    static {
<span class="fc" id="L64">        DEFAULT_EXCLUSIONS.add(&quot;vnic&quot;);</span>
<span class="fc" id="L65">        DEFAULT_EXCLUSIONS.add(&quot;tun0&quot;);</span>
<span class="fc" id="L66">    }</span>

    private DiscoveryListener listener;
    private URI discoveryURI;
<span class="fc" id="L70">    private int timeToLive = 1;</span>
    private boolean loopBackMode;
<span class="fc" id="L72">    private final Map&lt;URI, RemoteBrokerData&gt; brokersByService = new ConcurrentHashMap&lt;URI, RemoteBrokerData&gt;();</span>
<span class="fc" id="L73">    private String group = &quot;default&quot;;</span>
    private InetAddress inetAddress;
    private SocketAddress sockAddress;
    private MulticastSocket mcast;
    private Thread runner;
<span class="fc" id="L78">    private long keepAliveInterval = DEFAULT_IDLE_TIME;</span>
    private String mcInterface;
    private String mcNetworkInterface;
    private String mcJoinNetworkInterface;
    private String service;
<span class="fc" id="L83">    private final AtomicBoolean started = new AtomicBoolean(false);</span>
    private PacketParser parser;

<span class="fc" id="L86">    public MulticastDiscoveryAgent(URI discoveryURI) {</span>
<span class="fc" id="L87">        this.discoveryURI = discoveryURI;</span>
<span class="fc" id="L88">    }</span>

    @Override
    public void setDiscoveryListener(DiscoveryListener listener) {
<span class="nc" id="L92">        this.listener = listener;</span>
<span class="nc" id="L93">    }</span>

    public DiscoveryListener getDiscoveryListener() {
<span class="nc" id="L96">        return this.listener;</span>
    }

    @Override
    public void setScheduler(ScheduledExecutorService scheduler) {
        // Not needed for this agent
<span class="nc" id="L102">    }</span>

    @Override
    public boolean isSchedulerRequired() {
<span class="nc" id="L106">        return false;</span>
    }

    @Override
    public void start() throws IOException, IllegalStateException {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (listener == null) {</span>
<span class="nc" id="L112">            throw new IllegalStateException(&quot;No DiscoveryListener configured.&quot;);</span>
        }

<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (started.compareAndSet(false, true)) {</span>

<span class="nc bnc" id="L117" title="All 4 branches missed.">            if (group == null || group.length() == 0) {</span>
<span class="nc" id="L118">                throw new IOException(&quot;You must specify a group to discover&quot;);</span>
            }

<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (discoveryURI == null) {</span>
                try {
<span class="nc" id="L123">                    discoveryURI = new URI(DEFAULT_DISCOVERY_URI_STRING);</span>
<span class="nc" id="L124">                } catch (URISyntaxException e) {</span>
                    // Default is always valid.
<span class="nc" id="L126">                }</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">                if (discoveryURI == null) {</span>
<span class="nc" id="L129">                    throw new RuntimeException(&quot;Discovery URI unexpectedly null&quot;);</span>
                }
            }

<span class="nc" id="L133">            LOG.trace(&quot;mcast - discoveryURI = {}&quot;, discoveryURI);</span>

<span class="nc" id="L135">            String myHost = discoveryURI.getHost();</span>
<span class="nc" id="L136">            int myPort = discoveryURI.getPort();</span>

<span class="nc bnc" id="L138" title="All 4 branches missed.">            if (myHost == null || DEFAULT_HOST_STR.equals(myHost)) {</span>
<span class="nc" id="L139">                myHost = DEFAULT_HOST_IP;</span>
            }

<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (myPort &lt; 0) {</span>
<span class="nc" id="L143">                myPort = DEFAULT_PORT;</span>
            }

<span class="nc" id="L146">            LOG.trace(&quot;mcast - myHost = {}&quot;, myHost);</span>
<span class="nc" id="L147">            LOG.trace(&quot;mcast - myPort = {}&quot;, myPort);</span>
<span class="nc" id="L148">            LOG.trace(&quot;mcast - group = {}&quot;, group);</span>
<span class="nc" id="L149">            LOG.trace(&quot;mcast - interface = {}&quot;, mcInterface);</span>
<span class="nc" id="L150">            LOG.trace(&quot;mcast - network interface = {}&quot;, mcNetworkInterface);</span>
<span class="nc" id="L151">            LOG.trace(&quot;mcast - join network interface = {}&quot;, mcJoinNetworkInterface);</span>

<span class="nc" id="L153">            this.inetAddress = InetAddress.getByName(myHost);</span>
<span class="nc" id="L154">            this.sockAddress = new InetSocketAddress(this.inetAddress, myPort);</span>
<span class="nc" id="L155">            mcast = new MulticastSocket(myPort);</span>
<span class="nc" id="L156">            mcast.setLoopbackMode(loopBackMode);</span>
<span class="nc" id="L157">            mcast.setTimeToLive(getTimeToLive());</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (mcJoinNetworkInterface != null) {</span>
<span class="nc" id="L159">                mcast.joinGroup(sockAddress, NetworkInterface.getByName(mcJoinNetworkInterface));</span>
            } else {
<span class="nc bnc" id="L161" title="All 2 branches missed.">                if (mcNetworkInterface != null) {</span>
<span class="nc" id="L162">                    mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));</span>
                } else {
<span class="nc" id="L164">                    trySetNetworkInterface(mcast);</span>
                }
<span class="nc" id="L166">                mcast.joinGroup(inetAddress);</span>
            }
<span class="nc" id="L168">            mcast.setSoTimeout((int) keepAliveInterval);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (mcInterface != null) {</span>
<span class="nc" id="L170">                mcast.setInterface(InetAddress.getByName(mcInterface));</span>
            }

<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (mcNetworkInterface != null) {</span>
<span class="nc" id="L174">                mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));</span>
            }

<span class="nc" id="L177">            runner = new Thread(this);</span>
<span class="nc" id="L178">            runner.setName(this.toString() + &quot;:&quot; + runner.getName());</span>
<span class="nc" id="L179">            runner.setDaemon(true);</span>
<span class="nc" id="L180">            runner.start();</span>
        }
<span class="nc" id="L182">    }</span>

    @Override
    public void close() {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (started.compareAndSet(true, false)) {</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (mcast != null) {</span>
<span class="nc" id="L188">                mcast.close();</span>
            }
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (runner != null) {</span>
<span class="nc" id="L191">                runner.interrupt();</span>
            }
        }
<span class="nc" id="L194">    }</span>

    @Override
    public void suspend() {
        // We don't suspend multicast as it's mostly a passive listener.
<span class="nc" id="L199">    }</span>

    @Override
    public void resume() {
        // We don't suspend multicast as it's mostly a passive listener.
<span class="nc" id="L204">    }</span>

    @Override
    public void run() {
<span class="nc" id="L208">        byte[] buf = new byte[BUFF_SIZE];</span>
<span class="nc" id="L209">        DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        while (started.get()) {</span>
<span class="nc" id="L211">            expireOldServices();</span>
            try {
<span class="nc" id="L213">                mcast.receive(packet);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                if (packet.getLength() &gt; 0) {</span>
<span class="nc" id="L215">                    DiscoveryEvent event = parser.processPacket(packet.getData(), packet.getOffset(), packet.getLength());</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                    if (event != null) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                        if (event.getType() == EventType.ALIVE) {</span>
<span class="nc" id="L218">                            processAlive(event);</span>
                        } else {
<span class="nc" id="L220">                            processShutdown(event);</span>
                        }
                    }
                }
<span class="nc" id="L224">            } catch (SocketTimeoutException se) {</span>
                // ignore
<span class="nc" id="L226">            } catch (IOException e) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                if (started.get()) {</span>
<span class="nc" id="L228">                    LOG.error(&quot;failed to process packet: {}&quot;, e.getMessage());</span>
<span class="nc" id="L229">                    LOG.trace(&quot; packet processing failed by: {}&quot;, e);</span>
                }
<span class="nc" id="L231">            }</span>
        }
<span class="nc" id="L233">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L237">        return &quot;MulticastDiscoveryAgent: listener:&quot; + getDiscvoeryURI();</span>
    }

    //---------- Internal Implementation -------------------------------------//

    private void processAlive(DiscoveryEvent event) {
<span class="nc" id="L243">        RemoteBrokerData data = brokersByService.get(event.getPeerUri());</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L245">            URI peerUri = event.getPeerUri();</span>
<span class="nc" id="L246">            data = new RemoteBrokerData(event.getPeerUri());</span>
<span class="nc" id="L247">            brokersByService.put(peerUri, data);</span>
<span class="nc" id="L248">            fireServiceAddEvent(data);</span>
<span class="nc" id="L249">        } else {</span>
<span class="nc" id="L250">            data.updateHeartBeat();</span>
        }
<span class="nc" id="L252">    }</span>

    private void processShutdown(DiscoveryEvent event) {
<span class="nc" id="L255">        RemoteBrokerData data = brokersByService.remove(event.getPeerUri());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc" id="L257">            fireServiceRemovedEvent(data);</span>
        }
<span class="nc" id="L259">    }</span>

    private void expireOldServices() {
<span class="nc" id="L262">        long expireTime = System.currentTimeMillis() - (keepAliveInterval * HEARTBEAT_MISS_BEFORE_DEATH);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (Iterator&lt;RemoteBrokerData&gt; i = brokersByService.values().iterator(); i.hasNext();) {</span>
<span class="nc" id="L264">            RemoteBrokerData data = i.next();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (data.getLastHeartBeat() &lt; expireTime) {</span>
<span class="nc" id="L266">                processShutdown(data.asShutdownEvent());</span>
            }
<span class="nc" id="L268">        }</span>
<span class="nc" id="L269">    }</span>

    private void fireServiceRemovedEvent(final RemoteBrokerData data) {
<span class="nc bnc" id="L272" title="All 4 branches missed.">        if (listener != null &amp;&amp; started.get()) {</span>
<span class="nc" id="L273">            listener.onServiceRemove(data.getPeerUri());</span>
        }
<span class="nc" id="L275">    }</span>

    private void fireServiceAddEvent(final RemoteBrokerData data) {
<span class="nc bnc" id="L278" title="All 4 branches missed.">        if (listener != null &amp;&amp; started.get()) {</span>
<span class="nc" id="L279">            listener.onServiceAdd(data.getPeerUri());</span>
        }
<span class="nc" id="L281">    }</span>

    // ---------- Property Accessors ------------------------------------------//

    /**
     * @return the original URI used to create the Discovery Agent.
     */
    public URI getDiscvoeryURI() {
<span class="nc" id="L289">        return this.discoveryURI;</span>
    }

    /**
     * @return Returns the loopBackMode.
     */
    public boolean isLoopBackMode() {
<span class="nc" id="L296">        return loopBackMode;</span>
    }

    /**
     * @param loopBackMode
     *        The loopBackMode to set.
     */
    public void setLoopBackMode(boolean loopBackMode) {
<span class="nc" id="L304">        this.loopBackMode = loopBackMode;</span>
<span class="nc" id="L305">    }</span>

    /**
     * @return Returns the timeToLive.
     */
    public int getTimeToLive() {
<span class="nc" id="L311">        return timeToLive;</span>
    }

    /**
     * @param timeToLive
     *        The timeToLive to set.
     */
    public void setTimeToLive(int timeToLive) {
<span class="nc" id="L319">        this.timeToLive = timeToLive;</span>
<span class="nc" id="L320">    }</span>

    public long getKeepAliveInterval() {
<span class="nc" id="L323">        return keepAliveInterval;</span>
    }

    public void setKeepAliveInterval(long keepAliveInterval) {
<span class="nc" id="L327">        this.keepAliveInterval = keepAliveInterval;</span>
<span class="nc" id="L328">    }</span>

    public void setInterface(String mcInterface) {
<span class="nc" id="L331">        this.mcInterface = mcInterface;</span>
<span class="nc" id="L332">    }</span>

    public void setNetworkInterface(String mcNetworkInterface) {
<span class="nc" id="L335">        this.mcNetworkInterface = mcNetworkInterface;</span>
<span class="nc" id="L336">    }</span>

    public void setJoinNetworkInterface(String mcJoinNetwrokInterface) {
<span class="nc" id="L339">        this.mcJoinNetworkInterface = mcJoinNetwrokInterface;</span>
<span class="nc" id="L340">    }</span>

    /**
     * @return the multicast group this agent is assigned to.
     */
    public String getGroup() {
<span class="fc" id="L346">        return this.group;</span>
    }

    /**
     * Sets the multicast group this agent is assigned to.  The group can only be set
     * prior to starting the agent, once started the group change will never take effect.
     *
     * @param group
     *        the multicast group the agent is assigned to.
     */
    public void setGroup(String group) {
<span class="nc" id="L357">        this.group = group;</span>
<span class="nc" id="L358">    }</span>

    /**
     * Returns the name of the service that is providing the discovery data for this agent such
     * as ActiveMQ.
     *
     * @return the name of the service that is advertising remote peer data.
     */
    public String getService() {
<span class="fc" id="L367">        return this.service;</span>
    }

    /**
     * Sets the name of the service that is providing the remote peer discovery data.
     *
     * @param name
     *        the name of the service that provides this agent with remote peer data.
     */
    public void setService(String name) {
<span class="nc" id="L377">        this.service = name;</span>
<span class="nc" id="L378">    }</span>

    /**
     * @return the currently configured datagram packet parser for this agent.
     */
    public PacketParser getParser() {
<span class="nc" id="L384">        return parser;</span>
    }

    /**
     * Sets the datagram packet parser used to read the discovery data broadcast by the service
     * being monitored for remote peers.
     *
     * @param parser
     *        the datagram packet parser to use.
     */
    public void setParser(PacketParser parser) {
<span class="fc" id="L395">        this.parser = parser;</span>
<span class="fc" id="L396">    }</span>

    public static void trySetNetworkInterface(MulticastSocket mcastSock) throws SocketException {
<span class="nc" id="L399">        List&lt;NetworkInterface&gt; interfaces = findNetworkInterfaces();</span>
<span class="nc" id="L400">        SocketException lastError = null;</span>
<span class="nc" id="L401">        boolean found = false;</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">        for (NetworkInterface networkInterface : interfaces) {</span>
            try {
<span class="nc" id="L405">                mcastSock.setNetworkInterface(networkInterface);</span>
<span class="nc" id="L406">                LOG.debug(&quot;Configured mcast socket {} to network interface {}&quot;, mcastSock, networkInterface);</span>
<span class="nc" id="L407">                found = true;</span>
<span class="nc" id="L408">                break;</span>
<span class="nc" id="L409">            } catch (SocketException error) {</span>
<span class="nc" id="L410">                lastError = error;</span>
            }
<span class="nc" id="L412">        }</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (!found) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (lastError != null) {</span>
<span class="nc" id="L416">                throw lastError;</span>
            } else {
<span class="nc" id="L418">                throw new SocketException(&quot;No NetworkInterface available for this socket.&quot;);</span>
            }
        }
<span class="nc" id="L421">    }</span>

    private static List&lt;NetworkInterface&gt; findNetworkInterfaces() throws SocketException {
<span class="nc" id="L424">        Enumeration&lt;NetworkInterface&gt; ifcs = NetworkInterface.getNetworkInterfaces();</span>
<span class="nc" id="L425">        List&lt;NetworkInterface&gt; interfaces = new ArrayList&lt;NetworkInterface&gt;();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        while (ifcs.hasMoreElements()) {</span>
<span class="nc" id="L427">            NetworkInterface ni = ifcs.nextElement();</span>
<span class="nc" id="L428">            LOG.trace(&quot;findNetworkInterfaces checking interface: {}&quot;, ni);</span>

<span class="nc bnc" id="L430" title="All 4 branches missed.">            if (ni.supportsMulticast() &amp;&amp; ni.isUp()) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                for (InterfaceAddress ia : ni.getInterfaceAddresses()) {</span>
<span class="nc bnc" id="L432" title="All 6 branches missed.">                    if (ia.getAddress() instanceof java.net.Inet4Address &amp;&amp;</span>
                        !ia.getAddress().isLoopbackAddress() &amp;&amp;
                        !DEFAULT_EXCLUSIONS.contains(ni.getName())) {
                        // Add at the start, make usage order consistent with the
                        // existing ActiveMQ releases discovery will be used with.
<span class="nc" id="L437">                        interfaces.add(0, ni);</span>
<span class="nc" id="L438">                        break;</span>
                    }
<span class="nc" id="L440">                }</span>
            }
<span class="nc" id="L442">        }</span>

<span class="nc" id="L444">        LOG.trace(&quot;findNetworkInterfaces returning: {}&quot;, interfaces);</span>

<span class="nc" id="L446">        return interfaces;</span>
    }

    // ---------- Discovered Peer Bookkeeping Class ---------------------------//

    private static class RemoteBrokerData extends DiscoveryEvent {

        long lastHeartBeat;

        public RemoteBrokerData(URI peerUri) {
<span class="nc" id="L456">            super(peerUri, EventType.ALIVE);</span>
<span class="nc" id="L457">            this.lastHeartBeat = System.currentTimeMillis();</span>
<span class="nc" id="L458">        }</span>

        /**
         * @return an event representing this remote peers shutdown event.
         */
        public DiscoveryEvent asShutdownEvent() {
<span class="nc" id="L464">            return new DiscoveryEvent(getPeerUri(), EventType.SHUTDOWN);</span>
        }

        public synchronized void updateHeartBeat() {
<span class="nc" id="L468">            lastHeartBeat = System.currentTimeMillis();</span>
<span class="nc" id="L469">        }</span>

        public synchronized long getLastHeartBeat() {
<span class="nc" id="L472">            return lastHeartBeat;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>