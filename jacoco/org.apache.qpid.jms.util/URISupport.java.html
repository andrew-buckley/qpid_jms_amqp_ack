<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>URISupport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Client with AMQP acknowledgement</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms.util</a> &gt; <span class="el_source">URISupport.java</span></div><h1>URISupport.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms.util;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Provides support methods for dealing with URI values.
 */
<span class="nc" id="L30">public class URISupport {</span>

    /**
     * A composite URI can be split into one or more CompositeData object which each represent
     * the individual URIs that comprise the composite one.
     */
<span class="pc" id="L36">    public static class CompositeData {</span>

        private String host;
        private String scheme;
        private String path;
<span class="fc" id="L41">        private List&lt;URI&gt; components = Collections.emptyList();</span>
<span class="fc" id="L42">        private Map&lt;String, String&gt; parameters = Collections.emptyMap();</span>
        private String fragment;

        public List&lt;URI&gt; getComponents() {
<span class="fc" id="L46">            return components;</span>
        }

        public String getFragment() {
<span class="nc" id="L50">            return fragment;</span>
        }

        public Map&lt;String, String&gt; getParameters() {
<span class="fc" id="L54">            return parameters;</span>
        }

        public String getScheme() {
<span class="nc" id="L58">            return scheme;</span>
        }

        public String getPath() {
<span class="fc" id="L62">            return path;</span>
        }

        public String getHost() {
<span class="nc" id="L66">            return host;</span>
        }

        public URI toURI() throws URISyntaxException {
<span class="fc" id="L70">            StringBuffer sb = new StringBuffer();</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">            if (scheme != null) {</span>
<span class="fc" id="L72">                sb.append(scheme);</span>
<span class="fc" id="L73">                sb.append(':');</span>
            }

<span class="pc bpc" id="L76" title="2 of 4 branches missed.">            if (host != null &amp;&amp; host.length() != 0) {</span>
<span class="nc" id="L77">                sb.append(host);</span>
            } else {
<span class="fc" id="L79">                sb.append('(');</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                for (int i = 0; i &lt; components.size(); i++) {</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                    if (i != 0) {</span>
<span class="nc" id="L82">                        sb.append(',');</span>
                    }
<span class="fc" id="L84">                    sb.append(components.get(i).toString());</span>
                }
<span class="fc" id="L86">                sb.append(')');</span>
            }

<span class="pc bpc" id="L89" title="1 of 2 branches missed.">            if (path != null) {</span>
<span class="nc" id="L90">                sb.append('/');</span>
<span class="nc" id="L91">                sb.append(path);</span>
            }
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (!parameters.isEmpty()) {</span>
<span class="fc" id="L94">                sb.append(&quot;?&quot;);</span>
<span class="fc" id="L95">                sb.append(PropertyUtil.createQueryString(parameters));</span>
            }
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (fragment != null) {</span>
<span class="nc" id="L98">                sb.append(&quot;#&quot;);</span>
<span class="nc" id="L99">                sb.append(fragment);</span>
            }
<span class="fc" id="L101">            return new URI(sb.toString());</span>
        }
    }

    /**
     * Given a composite URI, parse the individual URI elements contained within that URI and
     * return a CompsoteData instance that contains the parsed URI values.
     *
     * @param uri
     *        The target URI that should be parsed.
     *
     * @return a new CompsiteData instance representing the parsed composite URI.
     * @throws URISyntaxException
     */
    public static CompositeData parseComposite(URI uri) throws URISyntaxException {

<span class="fc" id="L117">        CompositeData rc = new CompositeData();</span>
<span class="fc" id="L118">        rc.scheme = uri.getScheme();</span>
<span class="fc" id="L119">        String ssp = PropertyUtil.stripPrefix(uri.getRawSchemeSpecificPart().trim(), &quot;//&quot;).trim();</span>

        try {
<span class="fc" id="L122">            parseComposite(uri, rc, ssp);</span>
<span class="nc" id="L123">        } catch (Exception e) {</span>
<span class="nc" id="L124">            throw new URISyntaxException(uri.toString(), e.getMessage());</span>
<span class="fc" id="L125">        }</span>

<span class="fc" id="L127">        rc.fragment = uri.getFragment();</span>
<span class="fc" id="L128">        return rc;</span>
    }

    /**
     * Given a composite URI and a CompositeData instance and the scheme specific part extracted
     * from the source URI, parse the composite URI and populate the CompositeData object with
     * the results. The source URI is used only for logging as the ssp should have already been
     * extracted from it and passed here.
     *
     * @param uri
     *        The original source URI whose ssp is parsed into the composite data.
     * @param rc
     *        The CompsositeData instance that will be populated from the given ssp.
     * @param ssp
     *        The scheme specific part from the original string that is a composite or one or
     *        more URIs.
     *
     * @throws URISyntaxException
     */
    private static void parseComposite(URI uri, CompositeData rc, String ssp) throws Exception {
        String componentString;
        String params;

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (!checkParenthesis(ssp)) {</span>
<span class="nc" id="L152">            throw new URISyntaxException(uri.toString(), &quot;Not a matching number of '(' and ')' parenthesis&quot;);</span>
        }

        int p;
<span class="fc" id="L156">        int initialParen = ssp.indexOf(&quot;(&quot;);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (initialParen == 0) {</span>

<span class="fc" id="L159">            rc.host = ssp.substring(0, initialParen);</span>
<span class="fc" id="L160">            p = rc.host.indexOf(&quot;/&quot;);</span>

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            if (p &gt;= 0) {</span>
<span class="nc" id="L163">                rc.path = rc.host.substring(p);</span>
<span class="nc" id="L164">                rc.host = rc.host.substring(0, p);</span>
            }

<span class="fc" id="L167">            p = indexOfParenthesisMatch(ssp, initialParen);</span>
<span class="fc" id="L168">            componentString = ssp.substring(initialParen + 1, p);</span>
<span class="fc" id="L169">            params = ssp.substring(p + 1).trim();</span>

        } else {
<span class="fc" id="L172">            componentString = ssp;</span>
<span class="fc" id="L173">            params = &quot;&quot;;</span>
        }

<span class="fc" id="L176">        String components[] = splitComponents(componentString);</span>
<span class="fc" id="L177">        rc.components = new ArrayList&lt;URI&gt;(components.length);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (int i = 0; i &lt; components.length; i++) {</span>
<span class="fc" id="L179">            rc.components.add(new URI(components[i].trim()));</span>
        }

<span class="fc" id="L182">        p = params.indexOf(&quot;?&quot;);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (p &gt;= 0) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (p &gt; 0) {</span>
<span class="fc" id="L185">                rc.path = PropertyUtil.stripPrefix(params.substring(0, p), &quot;/&quot;);</span>
            }
<span class="fc" id="L187">            rc.parameters = PropertyUtil.parseQuery(params.substring(p + 1));</span>
        } else {
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (params.length() &gt; 0) {</span>
<span class="fc" id="L190">                rc.path = PropertyUtil.stripPrefix(params, &quot;/&quot;);</span>
            }
<span class="fc" id="L192">            rc.parameters = Collections.emptyMap();</span>
        }
<span class="fc" id="L194">    }</span>

    /**
     * Examine a URI and determine if it is a Composite type or not.
     *
     * @param uri
     *        The URI that is to be examined.
     *
     * @return true if the given URI is a Composite type.
     */
    public static boolean isCompositeURI(URI uri) {
<span class="fc" id="L205">        String ssp = PropertyUtil.stripPrefix(uri.getRawSchemeSpecificPart().trim(), &quot;//&quot;).trim();</span>

<span class="pc bpc" id="L207" title="1 of 4 branches missed.">        if (ssp.indexOf('(') == 0 &amp;&amp; checkParenthesis(ssp)) {</span>
<span class="fc" id="L208">            return true;</span>
        }
<span class="fc" id="L210">        return false;</span>
    }

    /**
     * Examine the supplied string and ensure that all parends appear as matching pairs.
     *
     * @param str
     *        The target string to examine.
     *
     * @return true if the target string has valid parend pairings.
     */
    public static boolean checkParenthesis(String str) {
<span class="fc" id="L222">        boolean result = true;</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (str != null) {</span>
<span class="fc" id="L224">            int open = 0;</span>
<span class="fc" id="L225">            int closed = 0;</span>

<span class="fc" id="L227">            int i = 0;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            while ((i = str.indexOf('(', i)) &gt;= 0) {</span>
<span class="fc" id="L229">                i++;</span>
<span class="fc" id="L230">                open++;</span>
            }
<span class="fc" id="L232">            i = 0;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            while ((i = str.indexOf(')', i)) &gt;= 0) {</span>
<span class="fc" id="L234">                i++;</span>
<span class="fc" id="L235">                closed++;</span>
            }
<span class="fc bfc" id="L237" title="All 2 branches covered.">            result = open == closed;</span>
        }
<span class="fc" id="L239">        return result;</span>
    }

    /**
     * Given a string and a position in that string of an open parend, find the matching close
     * parend.
     *
     * @param str
     *        The string to be searched for a matching parend.
     * @param first
     *        The index in the string of the opening parend whose close value is to be searched.
     *
     * @return the index in the string where the closing parend is located.
     *
     * @throws URISyntaxException
     *         if the string does not contain a matching parend.
     */
    public static int indexOfParenthesisMatch(String str, int first) throws URISyntaxException {
<span class="fc" id="L257">        int index = -1;</span>

<span class="pc bpc" id="L259" title="2 of 4 branches missed.">        if (first &lt; 0 || first &gt; str.length()) {</span>
<span class="nc" id="L260">            throw new IllegalArgumentException(&quot;Invalid position for first parenthesis: &quot; + first);</span>
        }

<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (str.charAt(first) != '(') {</span>
<span class="nc" id="L264">            throw new IllegalArgumentException(&quot;character at indicated position is not a parenthesis&quot;);</span>
        }

<span class="fc" id="L267">        int depth = 1;</span>
<span class="fc" id="L268">        char[] array = str.toCharArray();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        for (index = first + 1; index &lt; array.length; ++index) {</span>
<span class="fc" id="L270">            char current = array[index];</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (current == '(') {</span>
<span class="fc" id="L272">                depth++;</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">            } else if (current == ')') {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">                if (--depth == 0) {</span>
<span class="fc" id="L275">                    break;</span>
                }
            }
        }

<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (depth != 0) {</span>
<span class="nc" id="L281">            throw new URISyntaxException(str, &quot;URI did not contain a matching parenthesis.&quot;);</span>
        }

<span class="fc" id="L284">        return index;</span>
    }

    /**
     * Given the inner portion of a composite URI, split and return each inner URI as a string
     * element in a new String array.
     *
     * @param str
     *        The inner URI elements of a composite URI string.
     *
     * @return an array containing each inner URI from the composite one.
     */
    public static String[] splitComponents(String str) {
<span class="fc" id="L297">        List&lt;String&gt; l = new ArrayList&lt;String&gt;();</span>

<span class="fc" id="L299">        int last = 0;</span>
<span class="fc" id="L300">        int depth = 0;</span>
<span class="fc" id="L301">        char chars[] = str.toCharArray();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="fc bfc" id="L303" title="All 4 branches covered.">            switch (chars[i]) {</span>
                case '(':
<span class="fc" id="L305">                    depth++;</span>
<span class="fc" id="L306">                    break;</span>
                case ')':
<span class="fc" id="L308">                    depth--;</span>
<span class="fc" id="L309">                    break;</span>
                case ',':
<span class="fc bfc" id="L311" title="All 2 branches covered.">                    if (depth == 0) {</span>
<span class="fc" id="L312">                        String s = str.substring(last, i);</span>
<span class="fc" id="L313">                        l.add(s);</span>
<span class="fc" id="L314">                        last = i + 1;</span>
<span class="fc" id="L315">                    }</span>
                    break;
                default:
            }
        }

<span class="fc" id="L321">        String s = str.substring(last);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (s.length() != 0) {</span>
<span class="fc" id="L323">            l.add(s);</span>
        }

<span class="fc" id="L326">        String rc[] = new String[l.size()];</span>
<span class="fc" id="L327">        l.toArray(rc);</span>
<span class="fc" id="L328">        return rc;</span>
    }

    /**
     * Removes any URI query from the given uri and return a new URI that does not contain the
     * query portion.
     *
     * @param uri
     *        The URI whose query value is to be removed.
     *
     * @return a new URI that does not contain a query value.
     * @throws URISyntaxException
     */
    public static URI removeQuery(URI uri) throws URISyntaxException {
<span class="fc" id="L342">        return PropertyUtil.replaceQuery(uri, (String) null);</span>
    }

    /**
     * Given a URI parse and extract any URI query options and return them as a Key / Value
     * mapping.
     *
     * This method handles composite URI types and will extract the URI options
     * from the outermost composite URI.
     *
     * @param uri
     *        The URI whose query should be extracted and processed.
     *
     * @return A Mapping of the URI options.
     * @throws URISyntaxException
     */
    public static Map&lt;String, String&gt; parseParameters(URI uri) throws URISyntaxException {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (!isCompositeURI(uri)) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (uri.getQuery() == null) {</span>
<span class="fc" id="L361">                return Collections.emptyMap();</span>
            } else {
                try {
<span class="fc" id="L364">                    return PropertyUtil.parseQuery(PropertyUtil.stripPrefix(uri.getQuery(), &quot;?&quot;));</span>
<span class="nc" id="L365">                } catch (Exception e) {</span>
<span class="nc" id="L366">                    throw new URISyntaxException(uri.toString(), e.getMessage());</span>
                }
            }
        } else {
<span class="fc" id="L370">            CompositeData data = URISupport.parseComposite(uri);</span>
<span class="fc" id="L371">            Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L372">            parameters.putAll(data.getParameters());</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if (parameters.isEmpty()) {</span>
<span class="nc" id="L374">                parameters = Collections.emptyMap();</span>
            }

<span class="fc" id="L377">            return parameters;</span>
        }
    }

    /**
     * Given a Key / Value mapping create and append a URI query value that represents the
     * mapped entries, return the newly updated URI that contains the value of the given URI and
     * the appended query value.
     *
     * @param uri
     *        The source URI that will have the Map entries appended as a URI query value.
     * @param queryParameters
     *        The Key / Value mapping that will be transformed into a URI query string.
     *
     * @return A new URI value that combines the given URI and the constructed query string.
     * @throws URISyntaxException
     */
    public static URI applyParameters(URI uri, Map&lt;String, String&gt; queryParameters) throws URISyntaxException {
<span class="fc" id="L395">        return applyParameters(uri, queryParameters, &quot;&quot;);</span>
    }

    /**
     * Given a Key / Value mapping create and append a URI query value that represents the
     * mapped entries, return the newly updated URI that contains the value of the given URI and
     * the appended query value. Each entry in the query string is prefixed by the supplied
     * optionPrefix string.
     *
     * @param uri
     *        The source URI that will have the Map entries appended as a URI query value.
     * @param queryParameters
     *        The Key / Value mapping that will be transformed into a URI query string.
     * @param optionPrefix
     *        A string value that when not null or empty is used to prefix each query option
     *        key.
     *
     * @return A new URI value that combines the given URI and the constructed query string.
     * @throws URISyntaxException
     */
    public static URI applyParameters(URI uri, Map&lt;String, String&gt; queryParameters, String optionPrefix) throws URISyntaxException {
<span class="pc bpc" id="L416" title="2 of 4 branches missed.">        if (queryParameters != null &amp;&amp; !queryParameters.isEmpty()) {</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            StringBuffer newQuery = uri.getRawQuery() != null ? new StringBuffer(uri.getRawQuery()) : new StringBuffer();</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            for (Map.Entry&lt;String, String&gt; param : queryParameters.entrySet()) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if (param.getKey().startsWith(optionPrefix)) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">                    if (newQuery.length() != 0) {</span>
<span class="fc" id="L421">                        newQuery.append('&amp;');</span>
                    }
<span class="fc" id="L423">                    final String key = param.getKey().substring(optionPrefix.length());</span>
<span class="fc" id="L424">                    newQuery.append(key).append('=').append(param.getValue());</span>
                }
<span class="fc" id="L426">            }</span>
<span class="fc" id="L427">            uri = PropertyUtil.replaceQuery(uri, newQuery.toString());</span>
        }
<span class="fc" id="L429">        return uri;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>