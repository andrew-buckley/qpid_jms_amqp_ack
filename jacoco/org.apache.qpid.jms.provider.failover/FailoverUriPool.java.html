<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FailoverUriPool.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Client with AMQP acknowledgement</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms.provider.failover</a> &gt; <span class="el_source">FailoverUriPool.java</span></div><h1>FailoverUriPool.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms.provider.failover;

import java.io.IOException;
import java.net.InetAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.qpid.jms.util.URISupport;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages the list of available failover URIs that are used to connect
 * and recover a connection.
 */
public class FailoverUriPool {

<span class="fc" id="L39">    private static final Logger LOG = LoggerFactory.getLogger(FailoverUriPool.class);</span>

    public static final boolean DEFAULT_RANDOMIZE_ENABLED = false;

    private final LinkedList&lt;URI&gt; uris;
    private final Map&lt;String, String&gt; nestedOptions;
<span class="fc" id="L45">    private final AtomicBoolean randomize = new AtomicBoolean(DEFAULT_RANDOMIZE_ENABLED);</span>

<span class="fc" id="L47">    public FailoverUriPool() {</span>
<span class="fc" id="L48">        this.uris = new LinkedList&lt;URI&gt;();</span>
<span class="fc" id="L49">        this.nestedOptions = Collections.emptyMap();</span>
<span class="fc" id="L50">    }</span>

<span class="fc" id="L52">    public FailoverUriPool(List&lt;URI&gt; uris, Map&lt;String, String&gt; nestedOptions) {</span>
<span class="fc" id="L53">        this.uris = new LinkedList&lt;URI&gt;();</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        if (nestedOptions != null) {</span>
<span class="fc" id="L55">            this.nestedOptions = nestedOptions;</span>
        } else {
<span class="fc" id="L57">            this.nestedOptions = Collections.emptyMap();</span>
        }

<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (uris != null) {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">            for (URI uri : uris) {</span>
<span class="fc" id="L62">                this.add(uri);</span>
<span class="fc" id="L63">            }</span>
        }
<span class="fc" id="L65">    }</span>

    /**
     * @return the current size of the URI pool.
     */
    public int size() {
<span class="fc" id="L71">        synchronized (uris) {</span>
<span class="fc" id="L72">            return uris.size();</span>
<span class="nc" id="L73">        }</span>
    }

    /**
     * @return true if the URI pool is empty.
     */
    public boolean isEmpty() {
<span class="fc" id="L80">        synchronized (uris) {</span>
<span class="fc" id="L81">            return uris.isEmpty();</span>
<span class="nc" id="L82">        }</span>
    }

    /**
     * Returns the next URI in the pool of URIs.  The URI will be shifted to the
     * end of the list and not be attempted again until the full list has been
     * returned once.
     *
     * @return the next URI that should be used for a connection attempt.
     */
    public URI getNext() {
<span class="fc" id="L93">        URI next = null;</span>
<span class="fc" id="L94">        synchronized (uris) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (!uris.isEmpty()) {</span>
<span class="fc" id="L96">                next = uris.removeFirst();</span>
<span class="fc" id="L97">                uris.addLast(next);</span>
            }
<span class="pc" id="L99">        }</span>

<span class="fc" id="L101">        return next;</span>
    }

    /**
     * Reports that the Failover Provider connected to the last URI returned from
     * this pool.  If the Pool is set to randomize this will result in the Pool of
     * URIs being shuffled in preparation for the next connect cycle.
     */
    public void connected() {
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (isRandomize()) {</span>
<span class="fc" id="L111">            synchronized (uris) {</span>
<span class="fc" id="L112">                Collections.shuffle(uris);</span>
<span class="pc" id="L113">            }</span>
        }
<span class="fc" id="L115">    }</span>

    /**
     * @return true if this pool returns the URI values in random order.
     */
    public boolean isRandomize() {
<span class="fc" id="L121">        return randomize.get();</span>
    }

    /**
     * Sets whether the URIs that are returned by this pool are returned in random
     * order or not.  If false the URIs are returned in FIFO order.
     *
     * @param random
     *        true to have the URIs returned in a random order.
     */
    public void setRandomize(boolean random) {
<span class="fc bfc" id="L132" title="All 4 branches covered.">        if (randomize.compareAndSet(!random, random)) {</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            if (random) {</span>
<span class="fc" id="L134">                synchronized (uris) {</span>
<span class="fc" id="L135">                    Collections.shuffle(uris);</span>
<span class="pc" id="L136">                }</span>
            }
        }
<span class="fc" id="L139">    }</span>

    /**
     * Adds a new URI to the pool if not already contained within.  The URI will have
     * any nest options that have been configured added to its existing set of options.
     *
     * @param uri
     *        The new URI to add to the pool.
     */
    public void add(URI uri) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (uri == null) {</span>
<span class="fc" id="L150">            return;</span>
        }

<span class="fc" id="L153">        synchronized (uris) {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (!contains(uri)) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                if (!nestedOptions.isEmpty()) {</span>
                    try {
<span class="fc" id="L157">                        uri = URISupport.applyParameters(uri, nestedOptions);</span>
<span class="nc" id="L158">                    } catch (URISyntaxException e) {</span>
<span class="nc" id="L159">                        LOG.debug(&quot;Failed to add nested options to uri: {}&quot;, uri);</span>
<span class="fc" id="L160">                    }</span>
                }

<span class="fc" id="L163">                uris.add(uri);</span>
            }
<span class="pc" id="L165">        }</span>
<span class="fc" id="L166">    }</span>

    /**
     * Adds a new URI to the pool if not already contained within.  The URI will have
     * any nested options that have been configured added to its existing set of options.
     *
     * The URI is added to the head of the pooled URIs and will be the next value that
     * is returned from the pool.
     *
     * @param uri
     *        The new URI to add to the pool.
     */
    public void addFirst(URI uri) {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (uri == null) {</span>
<span class="fc" id="L180">            return;</span>
        }

<span class="fc" id="L183">        synchronized (uris) {</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            if (!contains(uri)) {</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                if (!nestedOptions.isEmpty()) {</span>
                    try {
<span class="nc" id="L187">                        uri = URISupport.applyParameters(uri, nestedOptions);</span>
<span class="nc" id="L188">                    } catch (URISyntaxException e) {</span>
<span class="nc" id="L189">                        LOG.debug(&quot;Failed to add nested options to uri: {}&quot;, uri);</span>
<span class="nc" id="L190">                    }</span>
                }

<span class="fc" id="L193">                uris.addFirst(uri);</span>
            }
<span class="pc" id="L195">        }</span>
<span class="fc" id="L196">    }</span>

    /**
     * Remove a URI from the pool if present, otherwise has no effect.
     *
     * @param uri
     *        The URI to attempt to remove from the pool.
     *
     * @return true if the given URI was removed from the pool.
     */
    public boolean remove(URI uri) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (uri == null) {</span>
<span class="fc" id="L208">            return false;</span>
        }

<span class="fc" id="L211">        synchronized (uris) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            for (URI candidate : uris) {</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">                if (compareURIs(uri, candidate)) {</span>
<span class="fc" id="L214">                    return uris.remove(candidate);</span>
                }
<span class="fc" id="L216">            }</span>
<span class="pc" id="L217">        }</span>

<span class="fc" id="L219">        return false;</span>
    }

    /**
     * Returns the currently set value for nested options which will be added to each
     * URI that is returned from the pool.
     *
     * @return the Map instance containing the nest options which can be empty if none set.
     */
    public Map&lt;String, String&gt; getNestedOptions() {
<span class="fc" id="L229">        return nestedOptions;</span>
    }

    //----- Internal methods that require the locks be held ------------------//

    private boolean contains(URI newURI) {
<span class="fc" id="L235">        boolean result = false;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (URI uri : uris) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (compareURIs(newURI, uri)) {</span>
<span class="fc" id="L238">                result = true;</span>
<span class="fc" id="L239">                break;</span>
            }
<span class="fc" id="L241">        }</span>

<span class="fc" id="L243">        return result;</span>
    }

    private boolean compareURIs(final URI first, final URI second) {
<span class="fc" id="L247">        boolean result = false;</span>
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">        if (first == null || second == null) {</span>
<span class="nc" id="L249">            return result;</span>
        }

<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (first.getPort() == second.getPort()) {</span>
<span class="fc" id="L253">            InetAddress firstAddr = null;</span>
<span class="fc" id="L254">            InetAddress secondAddr = null;</span>
            try {
<span class="fc" id="L256">                firstAddr = InetAddress.getByName(first.getHost());</span>
<span class="fc" id="L257">                secondAddr = InetAddress.getByName(second.getHost());</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">                if (firstAddr.equals(secondAddr)) {</span>
<span class="fc" id="L260">                    result = true;</span>
                }
<span class="fc" id="L262">            } catch(IOException e) {</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                if (firstAddr == null) {</span>
<span class="fc" id="L264">                    LOG.error(&quot;Failed to Lookup INetAddress for URI[ &quot; + first + &quot; ] : &quot; + e);</span>
                } else {
<span class="nc" id="L266">                    LOG.error(&quot;Failed to Lookup INetAddress for URI[ &quot; + second + &quot; ] : &quot; + e);</span>
                }

<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (first.getHost().equalsIgnoreCase(second.getHost())) {</span>
<span class="fc" id="L270">                    result = true;</span>
                }
<span class="fc" id="L272">            }</span>
        }

<span class="fc" id="L275">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>