<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FailoverProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Client with AMQP acknowledgement</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms.provider.failover</a> &gt; <span class="el_source">FailoverProvider.java</span></div><h1>FailoverProvider.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms.provider.failover;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import javax.jms.JMSException;

import org.apache.qpid.jms.message.JmsInboundMessageDispatch;
import org.apache.qpid.jms.message.JmsMessageFactory;
import org.apache.qpid.jms.message.JmsOutboundMessageDispatch;
import org.apache.qpid.jms.meta.JmsConnectionInfo;
import org.apache.qpid.jms.meta.JmsConsumerId;
import org.apache.qpid.jms.meta.JmsResource;
import org.apache.qpid.jms.meta.JmsSessionId;
import org.apache.qpid.jms.provider.AsyncResult;
import org.apache.qpid.jms.provider.DefaultProviderListener;
import org.apache.qpid.jms.provider.Provider;
import org.apache.qpid.jms.provider.ProviderConstants.ACK_TYPE;
import org.apache.qpid.jms.provider.ProviderFactory;
import org.apache.qpid.jms.provider.ProviderFuture;
import org.apache.qpid.jms.provider.ProviderListener;
import org.apache.qpid.jms.provider.ProviderRedirectedException;
import org.apache.qpid.jms.util.IOExceptionSupport;
import org.apache.qpid.jms.util.ThreadPoolUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A Provider Facade that provides services for detection dropped Provider connections
 * and attempting to reconnect to a different remote peer.  Upon establishment of a new
 * connection the FailoverProvider will initiate state recovery of the active JMS
 * framework resources.
 */
public class FailoverProvider extends DefaultProviderListener implements Provider {

<span class="fc" id="L65">    private static final Logger LOG = LoggerFactory.getLogger(FailoverProvider.class);</span>

    public static final int UNLIMITED = -1;

    public static final int DEFAULT_MAX_RECONNECT_ATTEMPTS = UNLIMITED;
    public static final int DEFAULT_STARTUP_MAX_RECONNECT_ATTEMPTS = UNLIMITED;
    public static final long DEFAULT_INITIAL_RECONNECT_DELAY = 0;
    public static final long DEFAULT_RECONNECT_DELAY = 10;
<span class="fc" id="L73">    public static final long DEFAULT_MAX_RECONNECT_DELAY = TimeUnit.SECONDS.toMillis(30);</span>
    public static final boolean DEFAULT_USE_RECONNECT_BACKOFF = true;
    public static final double DEFAULT_RECONNECT_BACKOFF_MULTIPLIER = 2.0d;
    public static final int DEFAULT_WARN_AFTER_RECONNECT_ATTEMPTS = 10;

    private ProviderListener listener;
    private Provider provider;
    private final FailoverUriPool uris;

    private final ExecutorService serializer;
    private final ScheduledExecutorService connectionHub;
<span class="fc" id="L84">    private final AtomicBoolean closed = new AtomicBoolean();</span>
<span class="fc" id="L85">    private final AtomicBoolean failed = new AtomicBoolean();</span>
<span class="fc" id="L86">    private final AtomicLong requestId = new AtomicLong();</span>
<span class="fc" id="L87">    private final Map&lt;Long, FailoverRequest&gt; requests = new LinkedHashMap&lt;Long, FailoverRequest&gt;();</span>
<span class="fc" id="L88">    private final DefaultProviderListener closedListener = new DefaultProviderListener();</span>
<span class="fc" id="L89">    private final AtomicReference&lt;JmsMessageFactory&gt; messageFactory = new AtomicReference&lt;JmsMessageFactory&gt;();</span>

    // Current state of connection / reconnection
<span class="fc" id="L92">    private boolean firstConnection = true;</span>
    private long reconnectAttempts;
<span class="fc" id="L94">    private long nextReconnectDelay = -1;</span>
    private IOException failureCause;
    private URI connectedURI;

    // Timeout values configured via JmsConnectionInfo
<span class="fc" id="L99">    private long connectTimeout = JmsConnectionInfo.DEFAULT_CONNECT_TIMEOUT;</span>
<span class="fc" id="L100">    private long closeTimeout = JmsConnectionInfo.DEFAULT_CLOSE_TIMEOUT;</span>
<span class="fc" id="L101">    private long sendTimeout =  JmsConnectionInfo.DEFAULT_SEND_TIMEOUT;</span>
<span class="fc" id="L102">    private long requestTimeout = JmsConnectionInfo.DEFAULT_REQUEST_TIMEOUT;</span>

    // Configuration values.
<span class="fc" id="L105">    private long initialReconnectDelay = DEFAULT_INITIAL_RECONNECT_DELAY;</span>
<span class="fc" id="L106">    private long reconnectDelay = DEFAULT_RECONNECT_DELAY;</span>
<span class="fc" id="L107">    private long maxReconnectDelay = DEFAULT_MAX_RECONNECT_DELAY;</span>
<span class="fc" id="L108">    private boolean useReconnectBackOff = DEFAULT_USE_RECONNECT_BACKOFF;</span>
<span class="fc" id="L109">    private double reconnectBackOffMultiplier = DEFAULT_RECONNECT_BACKOFF_MULTIPLIER;</span>
<span class="fc" id="L110">    private int maxReconnectAttempts = DEFAULT_MAX_RECONNECT_ATTEMPTS;</span>
<span class="fc" id="L111">    private int startupMaxReconnectAttempts = DEFAULT_STARTUP_MAX_RECONNECT_ATTEMPTS;</span>
<span class="fc" id="L112">    private int warnAfterReconnectAttempts = DEFAULT_WARN_AFTER_RECONNECT_ATTEMPTS;</span>

    public FailoverProvider(Map&lt;String, String&gt; nestedOptions) {
<span class="fc" id="L115">        this(null, nestedOptions);</span>
<span class="fc" id="L116">    }</span>

    public FailoverProvider(List&lt;URI&gt; uris) {
<span class="fc" id="L119">        this(uris, null);</span>
<span class="fc" id="L120">    }</span>

<span class="fc" id="L122">    public FailoverProvider(List&lt;URI&gt; uris, Map&lt;String, String&gt; nestedOptions) {</span>
<span class="fc" id="L123">        this.uris = new FailoverUriPool(uris, nestedOptions);</span>

<span class="fc" id="L125">        this.serializer = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>

            @Override
            public Thread newThread(Runnable runner) {
<span class="fc" id="L129">                Thread serial = new Thread(runner);</span>
<span class="fc" id="L130">                serial.setDaemon(true);</span>
<span class="fc" id="L131">                serial.setName(&quot;FailoverProvider: serialization thread&quot;);</span>
<span class="fc" id="L132">                return serial;</span>
            }
        });

        // All Connection attempts happen in this schedulers thread.  Once a connection
        // is established it will hand the open connection back to the serializer thread
        // for state recovery.
<span class="fc" id="L139">        this.connectionHub = Executors.newScheduledThreadPool(1, new ThreadFactory() {</span>

            @Override
            public Thread newThread(Runnable runner) {
<span class="fc" id="L143">                Thread serial = new Thread(runner);</span>
<span class="fc" id="L144">                serial.setDaemon(true);</span>
<span class="fc" id="L145">                serial.setName(&quot;FailoverProvider: connect thread&quot;);</span>
<span class="fc" id="L146">                return serial;</span>
            }
        });
<span class="fc" id="L149">    }</span>

    @Override
    public void connect() throws IOException {
<span class="fc" id="L153">        checkClosed();</span>
<span class="fc" id="L154">        LOG.debug(&quot;Initiating initial connection attempt task&quot;);</span>
<span class="fc" id="L155">        triggerReconnectionAttempt();</span>
<span class="fc" id="L156">    }</span>

    @Override
    public void start() throws IOException, IllegalStateException {
<span class="fc" id="L160">        checkClosed();</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (listener == null) {</span>
<span class="fc" id="L163">            throw new IllegalStateException(&quot;No ProviderListener registered.&quot;);</span>
        }
<span class="fc" id="L165">    }</span>

    @Override
    public void close() {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (closed.compareAndSet(false, true)) {</span>
<span class="fc" id="L170">            final ProviderFuture request = new ProviderFuture();</span>
<span class="fc" id="L171">            serializer.execute(new Runnable() {</span>

                @Override
                public void run() {
                    try {
<span class="fc bfc" id="L176" title="All 2 branches covered.">                        IOException error = failureCause != null ? failureCause : new IOException(&quot;Connection closed&quot;);</span>
<span class="fc" id="L177">                        List&lt;FailoverRequest&gt; pending = new ArrayList&lt;FailoverRequest&gt;(requests.values());</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                        for (FailoverRequest request : pending) {</span>
<span class="fc" id="L179">                            request.onFailure(error);</span>
<span class="fc" id="L180">                        }</span>

<span class="fc bfc" id="L182" title="All 2 branches covered.">                        if (provider != null) {</span>
<span class="fc" id="L183">                            provider.close();</span>
                        }
<span class="nc" id="L185">                    } catch (Exception e) {</span>
<span class="nc" id="L186">                        LOG.debug(&quot;Caught exception while closing connection&quot;);</span>
                    } finally {
<span class="pc" id="L188">                        ThreadPoolUtils.shutdownGraceful(connectionHub);</span>
<span class="pc bpc" id="L189" title="5 of 6 branches missed.">                        if (serializer != null) {</span>
<span class="pc" id="L190">                            serializer.shutdown();</span>
                        }
<span class="pc" id="L192">                        request.onSuccess();</span>
<span class="pc" id="L193">                    }</span>
<span class="fc" id="L194">                }</span>
            });

            try {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                if (this.closeTimeout &lt; 0) {</span>
<span class="nc" id="L199">                    request.sync();</span>
                } else {
<span class="fc" id="L201">                    request.sync(closeTimeout, TimeUnit.MILLISECONDS);</span>
                }
<span class="nc" id="L203">            } catch (IOException e) {</span>
<span class="nc" id="L204">                LOG.warn(&quot;Error caught while closing Provider: &quot;, e.getMessage());</span>
<span class="fc" id="L205">            }</span>
        }
<span class="fc" id="L207">    }</span>

    @Override
    public void create(final JmsResource resource, AsyncResult request) throws IOException, JMSException, UnsupportedOperationException {
<span class="fc" id="L211">        checkClosed();</span>
<span class="fc" id="L212">        FailoverRequest pending = null;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (resource instanceof JmsConnectionInfo) {</span>
<span class="fc" id="L214">            pending = new CreateConnectionRequest(request) {</span>
                @Override
                public void doTask() throws Exception {
<span class="fc" id="L217">                    JmsConnectionInfo connectionInfo = (JmsConnectionInfo) resource;</span>
<span class="fc" id="L218">                    connectTimeout = connectionInfo.getConnectTimeout();</span>
<span class="fc" id="L219">                    closeTimeout = connectionInfo.getCloseTimeout();</span>
<span class="fc" id="L220">                    sendTimeout = connectionInfo.getSendTimeout();</span>
<span class="fc" id="L221">                    requestTimeout = connectionInfo.getRequestTimeout();</span>

<span class="fc" id="L223">                    provider.create(resource, this);</span>
<span class="fc" id="L224">                }</span>

                @Override
                public String toString() {
<span class="fc" id="L228">                    return &quot;create -&gt; &quot; + resource;</span>
                }
            };
        } else {
<span class="fc" id="L232">            pending = new FailoverRequest(request) {</span>
                @Override
                public void doTask() throws Exception {
<span class="fc" id="L235">                    provider.create(resource, this);</span>
<span class="fc" id="L236">                }</span>

                @Override
                public String toString() {
<span class="fc" id="L240">                    return &quot;create -&gt; &quot; + resource;</span>
                }
            };
        }

<span class="fc" id="L245">        serializer.execute(pending);</span>
<span class="fc" id="L246">    }</span>

    @Override
    public void start(final JmsResource resource, final AsyncResult request) throws IOException, JMSException {
<span class="fc" id="L250">        checkClosed();</span>
<span class="fc" id="L251">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="fc" id="L254">                provider.start(resource, this);</span>
<span class="fc" id="L255">            }</span>

            @Override
            public String toString() {
<span class="fc" id="L259">                return &quot;start -&gt; &quot; + resource;</span>
            }
        };

<span class="fc" id="L263">        serializer.execute(pending);</span>
<span class="fc" id="L264">    }</span>

    @Override
    public void stop(final JmsResource resource, final AsyncResult request) throws IOException, JMSException {
<span class="nc" id="L268">        checkClosed();</span>
<span class="nc" id="L269">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="nc" id="L272">                provider.stop(resource, this);</span>
<span class="nc" id="L273">            }</span>

            @Override
            public String toString() {
<span class="nc" id="L277">                return &quot;stop -&gt; &quot; + resource;</span>
            }
        };

<span class="nc" id="L281">        serializer.execute(pending);</span>
<span class="nc" id="L282">    }</span>

    @Override
    public void destroy(final JmsResource resourceId, AsyncResult request) throws IOException, JMSException, UnsupportedOperationException {
<span class="fc" id="L286">        checkClosed();</span>
<span class="fc" id="L287">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws IOException, JMSException, UnsupportedOperationException {
<span class="fc" id="L290">                provider.destroy(resourceId, this);</span>
<span class="fc" id="L291">            }</span>

            @Override
            public boolean succeedsWhenOffline() {
                // Allow this to succeed, resource won't get recreated on reconnect.
<span class="fc" id="L296">                return true;</span>
            }

            @Override
            public String toString() {
<span class="fc" id="L301">                return &quot;destroy -&gt; &quot; + resourceId;</span>
            }
        };

<span class="fc" id="L305">        serializer.execute(pending);</span>
<span class="fc" id="L306">    }</span>

    @Override
    public void send(final JmsOutboundMessageDispatch envelope, AsyncResult request) throws IOException, JMSException {
<span class="fc" id="L310">        checkClosed();</span>
<span class="fc" id="L311">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="fc" id="L314">                provider.send(envelope, this);</span>
<span class="fc" id="L315">            }</span>

            @Override
            public String toString() {
<span class="fc" id="L319">                return &quot;send -&gt; &quot; + envelope;</span>
            }
        };

<span class="fc" id="L323">        serializer.execute(pending);</span>
<span class="fc" id="L324">    }</span>

    @Override
    public void acknowledge(final JmsSessionId sessionId, final ACK_TYPE ackType, AsyncResult request) throws IOException, JMSException {
<span class="nc" id="L328">        checkClosed();</span>
<span class="nc" id="L329">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="nc" id="L332">                provider.acknowledge(sessionId, ackType, this);</span>
<span class="nc" id="L333">            }</span>

            @Override
            public boolean succeedsWhenOffline() {
                // Allow this to succeed, acks would be stale.
<span class="nc" id="L338">                return true;</span>
            }

            @Override
            public String toString() {
<span class="nc" id="L343">                return &quot;session acknowledge -&gt; &quot; + sessionId;</span>
            }
        };

<span class="nc" id="L347">        serializer.execute(pending);</span>
<span class="nc" id="L348">    }</span>

    @Override
    public void acknowledge(final JmsInboundMessageDispatch envelope, final ACK_TYPE ackType, AsyncResult request) throws IOException, JMSException {
<span class="nc" id="L352">        checkClosed();</span>
<span class="nc" id="L353">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="nc" id="L356">                provider.acknowledge(envelope, ackType, this);</span>
<span class="nc" id="L357">            }</span>

            @Override
            public boolean succeedsWhenOffline() {
                // Allow this to succeed, acks would be stale.
<span class="nc" id="L362">                return true;</span>
            }

            @Override
            public String toString() {
<span class="nc" id="L367">                return &quot;message acknowledge -&gt; &quot; + envelope + &quot; ackType: &quot; + ackType;</span>
            }
        };

<span class="nc" id="L371">        serializer.execute(pending);</span>
<span class="nc" id="L372">    }</span>

    @Override
    public void commit(final JmsSessionId sessionId, AsyncResult request) throws IOException, JMSException, UnsupportedOperationException {
<span class="nc" id="L376">        checkClosed();</span>
<span class="nc" id="L377">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="nc" id="L380">                provider.commit(sessionId, this);</span>
<span class="nc" id="L381">            }</span>

            @Override
            public boolean failureWhenOffline() {
<span class="nc" id="L385">                return true;</span>
            }

            @Override
            public String toString() {
<span class="nc" id="L390">                return &quot;TX commit -&gt; &quot; + sessionId;</span>
            }
        };

<span class="nc" id="L394">        serializer.execute(pending);</span>
<span class="nc" id="L395">    }</span>

    @Override
    public void rollback(final JmsSessionId sessionId, AsyncResult request) throws IOException, JMSException, UnsupportedOperationException {
<span class="nc" id="L399">        checkClosed();</span>
<span class="nc" id="L400">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="nc" id="L403">                provider.rollback(sessionId, this);</span>
<span class="nc" id="L404">            }</span>

            @Override
            public boolean failureWhenOffline() {
<span class="nc" id="L408">                return true;</span>
            }

            @Override
            public String toString() {
<span class="nc" id="L413">                return &quot;TX rollback -&gt; &quot; + sessionId;</span>
            }
        };

<span class="nc" id="L417">        serializer.execute(pending);</span>
<span class="nc" id="L418">    }</span>

    @Override
    public void recover(final JmsSessionId sessionId, final AsyncResult request) throws IOException, UnsupportedOperationException {
<span class="fc" id="L422">        checkClosed();</span>
<span class="fc" id="L423">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="fc" id="L426">                provider.recover(sessionId, this);</span>
<span class="fc" id="L427">            }</span>

            @Override
            public boolean succeedsWhenOffline() {
<span class="nc" id="L431">                return true;</span>
            }

            @Override
            public String toString() {
<span class="fc" id="L436">                return &quot;recover -&gt; &quot; + sessionId;</span>
            }
        };

<span class="fc" id="L440">        serializer.execute(pending);</span>
<span class="fc" id="L441">    }</span>

    @Override
    public void unsubscribe(final String subscription, AsyncResult request) throws IOException, JMSException, UnsupportedOperationException {
<span class="fc" id="L445">        checkClosed();</span>
<span class="fc" id="L446">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="fc" id="L449">                provider.unsubscribe(subscription, this);</span>
<span class="fc" id="L450">            }</span>

            @Override
            public String toString() {
<span class="fc" id="L454">                return &quot;unsubscribe -&gt; &quot; + subscription;</span>
            }
        };

<span class="fc" id="L458">        serializer.execute(pending);</span>
<span class="fc" id="L459">    }</span>

    @Override
    public void pull(final JmsConsumerId consumerId, final long timeout, final AsyncResult request) throws IOException, UnsupportedOperationException {
<span class="nc" id="L463">        checkClosed();</span>
<span class="nc" id="L464">        final FailoverRequest pending = new FailoverRequest(request) {</span>
            @Override
            public void doTask() throws Exception {
<span class="nc" id="L467">                provider.pull(consumerId, timeout, this);</span>
<span class="nc" id="L468">            }</span>

            @Override
            public String toString() {
<span class="nc" id="L472">                return &quot;message pull -&gt; &quot; + consumerId;</span>
            }
        };

<span class="nc" id="L476">        serializer.execute(pending);</span>
<span class="nc" id="L477">    }</span>

    @Override
    public JmsMessageFactory getMessageFactory() {
<span class="fc" id="L481">        return messageFactory.get();</span>
    }

    //--------------- Connection Error and Recovery methods ------------------//

    /**
     * This method is always called from within the FailoverProvider's serialization thread.
     *
     * When a failure is encountered either from an outgoing request or from an error fired
     * from the underlying Provider instance this method is called to determine if a reconnect
     * is allowed and if so a new reconnect cycle is triggered on the connection thread.
     *
     * @param cause
     *        the error that triggered the failure of the provider.
     */
    private void handleProviderFailure(final IOException cause) {
<span class="fc" id="L497">        LOG.debug(&quot;handling Provider failure: {}&quot;, cause.getMessage());</span>
<span class="fc" id="L498">        LOG.trace(&quot;stack&quot;, cause);</span>

<span class="fc" id="L500">        this.provider.setProviderListener(closedListener);</span>
<span class="fc" id="L501">        URI failedURI = this.provider.getRemoteURI();</span>
        try {
<span class="fc" id="L503">            this.provider.close();</span>
<span class="nc" id="L504">        } catch (Throwable error) {</span>
<span class="nc" id="L505">            LOG.trace(&quot;Caught exception while closing failed provider: {}&quot;, error.getMessage());</span>
<span class="fc" id="L506">        }</span>
<span class="fc" id="L507">        this.provider = null;</span>

<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        if (reconnectAllowed()) {</span>

<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (cause instanceof ProviderRedirectedException) {</span>
<span class="fc" id="L512">                ProviderRedirectedException redirect = (ProviderRedirectedException) cause;</span>
                try {
<span class="fc" id="L514">                    uris.addFirst(new URI(failedURI.getScheme() + &quot;://&quot; + redirect.getNetworkHost() + &quot;:&quot; + redirect.getPort()));</span>
<span class="nc" id="L515">                } catch (URISyntaxException ex) {</span>
<span class="nc" id="L516">                    LOG.warn(&quot;Could not construct redirection URI from remote provided information&quot;);</span>
<span class="fc" id="L517">                }</span>
            }

<span class="fc" id="L520">            ProviderListener listener = this.listener;</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L522">                listener.onConnectionInterrupted(failedURI);</span>
            }
<span class="fc" id="L524">            triggerReconnectionAttempt();</span>
<span class="fc" id="L525">        } else {</span>
<span class="nc" id="L526">            ProviderListener listener = this.listener;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (listener != null) {</span>
<span class="nc" id="L528">                listener.onConnectionFailure(cause);</span>
            }
        }
<span class="fc" id="L531">    }</span>

    /**
     * Called from the reconnection thread.  This method enqueues a new task that
     * will attempt to recover connection state, once successful, normal operations
     * will resume.  If an error occurs while attempting to recover the JMS framework
     * state then a reconnect cycle is again triggered on the connection thread.
     *
     * @param provider
     *        The newly connect Provider instance that will become active.
     */
    private void initializeNewConnection(final Provider provider) {
<span class="fc" id="L543">        this.serializer.execute(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L547">                    FailoverProvider.this.provider = provider;</span>
<span class="fc" id="L548">                    provider.setProviderListener(FailoverProvider.this);</span>

<span class="fc bfc" id="L550" title="All 2 branches covered.">                    if (!firstConnection) {</span>
<span class="fc" id="L551">                        LOG.debug(&quot;Signalling connection recovery: {}&quot;, provider);</span>

                        // Stage 1: Allow listener to recover its resources
<span class="fc" id="L554">                        listener.onConnectionRecovery(provider);</span>

                        // Stage 2: Connection state recovered, get newly configured message factory.
<span class="fc" id="L557">                        FailoverProvider.this.messageFactory.set(provider.getMessageFactory());</span>

                        // Stage 3: Restart consumers, send pull commands, etc.
<span class="fc" id="L560">                        listener.onConnectionRecovered(provider);</span>

                        // Stage 4: Let the client know that connection has restored.
<span class="fc" id="L563">                        listener.onConnectionRestored(provider.getRemoteURI());</span>
                    }

                    // Last step: Send pending actions.
<span class="fc" id="L567">                    List&lt;FailoverRequest&gt; pending = new ArrayList&lt;FailoverRequest&gt;(requests.values());</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                    for (FailoverRequest request : pending) {</span>
<span class="fc" id="L569">                        request.run();</span>
<span class="fc" id="L570">                    }</span>

<span class="fc" id="L572">                    nextReconnectDelay = reconnectDelay;</span>
<span class="fc" id="L573">                    reconnectAttempts = 0;</span>
<span class="fc" id="L574">                    connectedURI = provider.getRemoteURI();</span>
<span class="fc" id="L575">                    uris.connected();</span>
<span class="fc" id="L576">                } catch (Throwable error) {</span>
<span class="nc" id="L577">                    handleProviderFailure(IOExceptionSupport.create(error));</span>
<span class="fc" id="L578">                }</span>
<span class="fc" id="L579">            }</span>
        });
<span class="fc" id="L581">    }</span>

    /**
     * Called when the Provider was either first created or when a connection failure has
     * been reported.  A reconnection attempt is immediately executed on the connection
     * thread.  If a new Provider is able to be created and connected then a recovery task
     * is scheduled on the main serializer thread.  If the connect attempt fails another
     * attempt is scheduled based on the configured delay settings until a max attempts
     * limit is hit, if one is set.
     *
     * Since the initialize is put on the serializer thread this thread stops and does
     * not queue another connect task.  This allows for the reconnect delay to be reset
     * and a failure to initialize a new connection restarts the connect process from the
     * point of view that connection was lost and an immediate attempt cycle should start.
     */
    private void triggerReconnectionAttempt() {
<span class="pc bpc" id="L597" title="2 of 4 branches missed.">        if (closed.get() || failed.get()) {</span>
<span class="nc" id="L598">            return;</span>
        }

<span class="fc" id="L601">        connectionHub.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="pc bpc" id="L604" title="2 of 6 branches missed.">                if (provider != null || closed.get() || failed.get()) {</span>
<span class="fc" id="L605">                    return;</span>
                }

<span class="fc" id="L608">                int reconnectLimit = reconnectAttemptLimit();</span>
<span class="pc bpc" id="L609" title="1 of 4 branches missed.">                if (reconnectLimit != UNLIMITED &amp;&amp; reconnectAttempts &gt;= reconnectLimit) {</span>
<span class="nc" id="L610">                    return;</span>
                }

<span class="pc bpc" id="L613" title="3 of 4 branches missed.">                if (initialReconnectDelay &gt; 0 &amp;&amp; reconnectAttempts == 0) {</span>
<span class="nc" id="L614">                    LOG.trace(&quot;Delayed initial reconnect attempt will be in {} milliseconds&quot;, initialReconnectDelay);</span>
<span class="nc" id="L615">                    connectionHub.schedule(this, initialReconnectDelay, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L616">                    return;</span>
                }

<span class="fc" id="L619">                reconnectAttempts++;</span>
<span class="fc" id="L620">                Throwable failure = null;</span>
<span class="fc" id="L621">                URI target = uris.getNext();</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">                if (target != null) {</span>
<span class="fc" id="L623">                    Provider provider = null;</span>
                    try {
<span class="fc" id="L625">                        LOG.debug(&quot;Connection attempt:[{}] to: {} in-progress&quot;, reconnectAttempts, target);</span>
<span class="fc" id="L626">                        provider = ProviderFactory.create(target);</span>
<span class="fc" id="L627">                        provider.connect();</span>
<span class="fc" id="L628">                        initializeNewConnection(provider);</span>
<span class="fc" id="L629">                        return;</span>
<span class="fc" id="L630">                    } catch (Throwable e) {</span>
<span class="fc" id="L631">                        LOG.info(&quot;Connection attempt:[{}] to: {} failed&quot;, reconnectAttempts, target);</span>
<span class="fc" id="L632">                        failure = e;</span>
                        try {
<span class="fc" id="L634">                            provider.close();</span>
<span class="pc" id="L635">                        } catch (Throwable ex) {}</span>
                    }
<span class="fc" id="L637">                } else {</span>
<span class="nc" id="L638">                    LOG.debug(&quot;No target URI available to connect to&quot;);</span>
                }

<span class="pc bpc" id="L641" title="1 of 4 branches missed.">                if (reconnectLimit != UNLIMITED &amp;&amp; reconnectAttempts &gt;= reconnectLimit) {</span>
<span class="fc" id="L642">                    LOG.error(&quot;Failed to connect after: &quot; + reconnectAttempts + &quot; attempt(s)&quot;);</span>
<span class="fc" id="L643">                    failed.set(true);</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">                    if(failure == null) {</span>
<span class="nc" id="L645">                        failureCause = new IOException(&quot;Failed to connect after: &quot; + reconnectAttempts + &quot; attempt(s)&quot;);</span>
                    } else {
<span class="fc" id="L647">                        failureCause = IOExceptionSupport.create(failure);</span>
                    }
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L650">                        listener.onConnectionFailure(failureCause);</span>
                    };

<span class="fc" id="L653">                    return;</span>
                }

<span class="fc" id="L656">                int warnInterval = getWarnAfterReconnectAttempts();</span>
<span class="pc bpc" id="L657" title="2 of 4 branches missed.">                if (warnInterval &gt; 0 &amp;&amp; (reconnectAttempts % warnInterval) == 0) {</span>
<span class="nc" id="L658">                    LOG.warn(&quot;Failed to connect after: {} attempt(s) continuing to retry.&quot;, reconnectAttempts);</span>
                }

<span class="fc" id="L661">                long delay = nextReconnectDelay();</span>
<span class="fc" id="L662">                LOG.trace(&quot;Next reconnect attempt will be in {} milliseconds&quot;, delay);</span>
<span class="fc" id="L663">                connectionHub.schedule(this, delay, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L664">            }</span>
        });
<span class="fc" id="L666">    }</span>

    private boolean reconnectAllowed() {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        return reconnectAttemptLimit() != 0;</span>
    }

    private int reconnectAttemptLimit() {
<span class="fc" id="L673">        int maxReconnectValue = this.maxReconnectAttempts;</span>
<span class="fc bfc" id="L674" title="All 4 branches covered.">        if (firstConnection &amp;&amp; this.startupMaxReconnectAttempts != UNLIMITED) {</span>
<span class="fc" id="L675">            maxReconnectValue = this.startupMaxReconnectAttempts;</span>
        }
<span class="fc" id="L677">        return maxReconnectValue;</span>
    }

    private long nextReconnectDelay() {

<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (nextReconnectDelay == -1) {</span>
<span class="fc" id="L683">            nextReconnectDelay = reconnectDelay;</span>
        }

<span class="fc bfc" id="L686" title="All 4 branches covered.">        if (isUseReconnectBackOff() &amp;&amp; reconnectAttempts &gt; 1) {</span>
            // Exponential increment of reconnect delay.
<span class="fc" id="L688">            nextReconnectDelay *= getReconnectBackOffMultiplier();</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            if (nextReconnectDelay &gt; maxReconnectDelay) {</span>
<span class="fc" id="L690">                nextReconnectDelay = maxReconnectDelay;</span>
            }
        }

<span class="fc" id="L694">        return nextReconnectDelay;</span>
    }

    protected void checkClosed() throws IOException {
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (closed.get()) {</span>
<span class="fc" id="L699">            throw new IOException(&quot;The Provider is already closed&quot;);</span>
        }
<span class="fc" id="L701">    }</span>

    //--------------- DefaultProviderListener overrides ----------------------//

    @Override
    public void onInboundMessage(final JmsInboundMessageDispatch envelope) {
<span class="nc bnc" id="L707" title="All 4 branches missed.">        if (closed.get() || failed.get()) {</span>
<span class="nc" id="L708">            return;</span>
        }
<span class="nc" id="L710">        serializer.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc bnc" id="L713" title="All 2 branches missed.">                if (!closed.get()) {</span>
<span class="nc" id="L714">                    listener.onInboundMessage(envelope);</span>
                }
<span class="nc" id="L716">            }</span>
        });
<span class="nc" id="L718">    }</span>

    @Override
    public void onConnectionFailure(final IOException ex) {
<span class="pc bpc" id="L722" title="2 of 4 branches missed.">        if (closed.get() || failed.get()) {</span>
<span class="nc" id="L723">            return;</span>
        }
<span class="fc" id="L725">        serializer.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="pc bpc" id="L728" title="2 of 4 branches missed.">                if (!closed.get() &amp;&amp; !failed.get()) {</span>
<span class="fc" id="L729">                    LOG.debug(&quot;Failover: the provider reports failure: {}&quot;, ex.getMessage());</span>
<span class="fc" id="L730">                    handleProviderFailure(ex);</span>
                }
<span class="fc" id="L732">            }</span>
        });
<span class="fc" id="L734">    }</span>

    //--------------- URI update and rebalance methods -----------------------//

    public void add(final URI uri) {
<span class="nc" id="L739">        serializer.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc" id="L742">                uris.add(uri);</span>
<span class="nc" id="L743">            }</span>
        });
<span class="nc" id="L745">    }</span>

    public void remove(final URI uri) {
<span class="nc" id="L748">        serializer.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc" id="L751">                uris.remove(uri);</span>
<span class="nc" id="L752">            }</span>
        });
<span class="nc" id="L754">    }</span>

    //--------------- Property Getters and Setters ---------------------------//

    @Override
    public URI getRemoteURI() {
<span class="fc" id="L760">        Provider provider = this.provider;</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (provider != null) {</span>
<span class="fc" id="L762">            return provider.getRemoteURI();</span>
        }
<span class="fc" id="L764">        return null;</span>
    }

    @Override
    public void setProviderListener(ProviderListener listener) {
<span class="fc" id="L769">        this.listener = listener;</span>
<span class="fc" id="L770">    }</span>

    @Override
    public ProviderListener getProviderListener() {
<span class="fc" id="L774">        return listener;</span>
    }

    public boolean isRandomize() {
<span class="fc" id="L778">        return uris.isRandomize();</span>
    }

    public void setRandomize(boolean value) {
<span class="fc" id="L782">        this.uris.setRandomize(value);</span>
<span class="fc" id="L783">    }</span>

    public long getInitialReconnectDelay() {
<span class="fc" id="L786">        return initialReconnectDelay;</span>
    }

    public void setInitialReconnectDelay(long initialReconnectDelay) {
<span class="fc" id="L790">        this.initialReconnectDelay = initialReconnectDelay;</span>
<span class="fc" id="L791">    }</span>

    public long getReconnectDelay() {
<span class="fc" id="L794">        return reconnectDelay;</span>
    }

    public void setReconnectDelay(long reconnectDealy) {
<span class="fc" id="L798">        this.reconnectDelay = reconnectDealy;</span>
<span class="fc" id="L799">    }</span>

    public long getMaxReconnectDelay() {
<span class="fc" id="L802">        return maxReconnectDelay;</span>
    }

    public void setMaxReconnectDelay(long maxReconnectDelay) {
<span class="fc" id="L806">        this.maxReconnectDelay = maxReconnectDelay;</span>
<span class="fc" id="L807">    }</span>

    public int getMaxReconnectAttempts() {
<span class="fc" id="L810">        return maxReconnectAttempts;</span>
    }

    public void setMaxReconnectAttempts(int maxReconnectAttempts) {
<span class="fc" id="L814">        this.maxReconnectAttempts = maxReconnectAttempts;</span>
<span class="fc" id="L815">    }</span>

    public int getStartupMaxReconnectAttempts() {
<span class="fc" id="L818">        return startupMaxReconnectAttempts;</span>
    }

    public void setStartupMaxReconnectAttempts(int startupMaxReconnectAttempts) {
<span class="fc" id="L822">        this.startupMaxReconnectAttempts = startupMaxReconnectAttempts;</span>
<span class="fc" id="L823">    }</span>

    /**
     * Gets the current setting controlling how many Connect / Reconnect attempts must occur
     * before a warn message is logged.  A value of {@literal &lt;= 0} indicates that there will be
     * no warn message logged regardless of how many reconnect attempts occur.
     *
     * @return the current number of connection attempts before warn logging is triggered.
     */
    public int getWarnAfterReconnectAttempts() {
<span class="fc" id="L833">        return warnAfterReconnectAttempts;</span>
    }

    /**
     * Sets the number of Connect / Reconnect attempts that must occur before a warn message
     * is logged indicating that the transport is not connected.  This can be useful when the
     * client is running inside some container or service as it gives an indication of some
     * problem with the client connection that might not otherwise be visible.  To disable the
     * log messages this value should be set to a value {@literal &lt;= 0}
     *
     * @param warnAfterReconnectAttempts
     *        The number of failed connection attempts that must happen before a warning is logged.
     */
    public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts) {
<span class="fc" id="L847">        this.warnAfterReconnectAttempts = warnAfterReconnectAttempts;</span>
<span class="fc" id="L848">    }</span>

    public double getReconnectBackOffMultiplier() {
<span class="fc" id="L851">        return reconnectBackOffMultiplier;</span>
    }

    public void setReconnectBackOffMultiplier(double reconnectBackOffMultiplier) {
<span class="fc" id="L855">        this.reconnectBackOffMultiplier = reconnectBackOffMultiplier;</span>
<span class="fc" id="L856">    }</span>

    public boolean isUseReconnectBackOff() {
<span class="fc" id="L859">        return useReconnectBackOff;</span>
    }

    public void setUseReconnectBackOff(boolean useReconnectBackOff) {
<span class="fc" id="L863">        this.useReconnectBackOff = useReconnectBackOff;</span>
<span class="fc" id="L864">    }</span>

    public long getConnectTimeout() {
<span class="fc" id="L867">        return this.connectTimeout;</span>
    }

    public long getCloseTimeout() {
<span class="fc" id="L871">        return this.closeTimeout;</span>
    }

    public long getSendTimeout() {
<span class="fc" id="L875">        return this.sendTimeout;</span>
    }

    public long getRequestTimeout() {
<span class="fc" id="L879">        return this.requestTimeout;</span>
    }

    public Map&lt;String, String&gt; getNestedOptions() {
<span class="fc" id="L883">        return uris.getNestedOptions();</span>
    }

    @Override
    public String toString() {
<span class="fc bfc" id="L888" title="All 2 branches covered.">        return &quot;FailoverProvider: &quot; +</span>
               (connectedURI == null ? &quot;unconnected&quot; : connectedURI.toString());
    }

    //--------------- FailoverProvider Asynchronous Request --------------------//

    /**
     * For all requests that are dispatched from the FailoverProvider to a connected
     * Provider instance an instance of FailoverRequest is used to handle errors that
     * occur during processing of that request and trigger a reconnect.
     */
    protected abstract class FailoverRequest extends ProviderFuture implements Runnable {

<span class="fc" id="L901">        private final long id = requestId.incrementAndGet();</span>

<span class="fc" id="L903">        public FailoverRequest(AsyncResult watcher) {</span>
<span class="fc" id="L904">            super(watcher);</span>
<span class="fc" id="L905">        }</span>

        @Override
        public void run() {
<span class="fc" id="L909">            requests.put(id, this);</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">            if (provider == null) {</span>
<span class="fc" id="L911">                whenOffline(new IOException(&quot;Connection failed.&quot;));</span>
            } else {
                try {
<span class="fc" id="L914">                    LOG.debug(&quot;Executing Failover Task: {}&quot;, this);</span>
<span class="fc" id="L915">                    doTask();</span>
<span class="nc" id="L916">                } catch (UnsupportedOperationException e) {</span>
<span class="nc" id="L917">                    requests.remove(id);</span>
<span class="nc" id="L918">                    getWrappedRequest().onFailure(e);</span>
<span class="nc" id="L919">                } catch (JMSException jmsEx) {</span>
<span class="nc" id="L920">                    requests.remove(id);</span>
<span class="nc" id="L921">                    getWrappedRequest().onFailure(jmsEx);</span>
<span class="fc" id="L922">                } catch (Throwable e) {</span>
<span class="fc" id="L923">                    LOG.debug(&quot;Caught exception while executing task: {} - {}&quot;, this, e.getMessage());</span>
<span class="fc" id="L924">                    whenOffline(IOExceptionSupport.create(e));</span>
<span class="fc" id="L925">                    handleProviderFailure(IOExceptionSupport.create(e));</span>
<span class="pc" id="L926">                }</span>
            }
<span class="fc" id="L928">        }</span>

        @Override
        public void onFailure(final Throwable result) {
<span class="pc bpc" id="L932" title="1 of 4 branches missed.">            if (closed.get() || failed.get()) {</span>
<span class="fc" id="L933">                requests.remove(id);</span>
<span class="fc" id="L934">                super.onFailure(result);</span>
            } else {
<span class="fc" id="L936">                LOG.debug(&quot;Request received error: {}&quot;, result.getMessage());</span>
<span class="fc" id="L937">                serializer.execute(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L940">                        handleProviderFailure(IOExceptionSupport.create(result));</span>
<span class="fc" id="L941">                    }</span>
                });
            }
<span class="fc" id="L944">        }</span>

        @Override
        public void onSuccess() {
<span class="fc" id="L948">            requests.remove(id);</span>
<span class="fc" id="L949">            super.onSuccess();</span>
<span class="fc" id="L950">        }</span>

        /**
         * Called to execute the specific task that was requested.
         *
         * @throws Exception if an error occurs during task execution.
         */
        public abstract void doTask() throws Exception;

        /**
         * Should the request just succeed when the Provider is not connected.
         *
         * @return true if the request is marked as successful when not connected.
         */
        public boolean succeedsWhenOffline() {
<span class="fc" id="L965">            return false;</span>
        }

        /**
         * When the transport is not connected should this request automatically fail.
         *
         * @return true if the task should fail when the Provider is not connected.
         */
        public boolean failureWhenOffline() {
<span class="fc" id="L974">            return false;</span>
        }

        private void whenOffline(IOException error) {
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">            if (failureWhenOffline()) {</span>
<span class="nc" id="L979">                requests.remove(id);</span>
<span class="nc" id="L980">                getWrappedRequest().onFailure(IOExceptionSupport.create(error));</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">            } else if (succeedsWhenOffline()) {</span>
<span class="fc" id="L982">                onSuccess();</span>
            } else {
<span class="fc" id="L984">                LOG.trace(&quot;Task {} held until connection recovered:&quot;, this);</span>
            }
<span class="fc" id="L986">        }</span>
    }

    /**
     * Captures the initial request to create a JmsConnectionInfo based resources and ensures
     * that if the connection is successfully established that the connection established event
     * is triggered once before moving on to sending only connection interrupted and restored
     * events.
     *
     * The connection state events must all be triggered from the FailoverProvider's serialization
     * thread, this class ensures that the connection established event follows that pattern.
     */
    protected abstract class CreateConnectionRequest extends FailoverRequest {

        /**
         * @param watcher
         */
<span class="fc" id="L1003">        public CreateConnectionRequest(AsyncResult watcher) {</span>
<span class="fc" id="L1004">            super(watcher);</span>
<span class="fc" id="L1005">        }</span>

        @Override
        public void onSuccess() {
<span class="fc" id="L1009">            serializer.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">                    if (firstConnection) {</span>
<span class="fc" id="L1013">                        LOG.trace(&quot;First connection requst has completed:&quot;);</span>
<span class="fc" id="L1014">                        FailoverProvider.this.messageFactory.set(provider.getMessageFactory());</span>
<span class="fc" id="L1015">                        listener.onConnectionEstablished(provider.getRemoteURI());</span>
<span class="fc" id="L1016">                        firstConnection = false;</span>
                    } else {
<span class="nc" id="L1018">                        LOG.warn(&quot;A second call to a CreateConnectionRequest not expected.&quot;);</span>
                    }

<span class="fc" id="L1021">                    CreateConnectionRequest.this.signalConnected();</span>
<span class="fc" id="L1022">                }</span>
            });
<span class="fc" id="L1024">        }</span>

        public void signalConnected() {
<span class="fc" id="L1027">            super.onSuccess();</span>
<span class="fc" id="L1028">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>