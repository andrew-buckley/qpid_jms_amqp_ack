<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JmsConnectionFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Client with AMQP acknowledgement</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms</a> &gt; <span class="el_source">JmsConnectionFactory.java</span></div><h1>JmsConnectionFactory.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import javax.jms.IllegalStateException;
import javax.jms.JMSException;
import javax.jms.QueueConnection;
import javax.jms.QueueConnectionFactory;
import javax.jms.TopicConnection;
import javax.jms.TopicConnectionFactory;

import org.apache.qpid.jms.exceptions.JmsExceptionSupport;
import org.apache.qpid.jms.jndi.JNDIStorable;
import org.apache.qpid.jms.meta.JmsConnectionInfo;
import org.apache.qpid.jms.provider.Provider;
import org.apache.qpid.jms.provider.ProviderFactory;
import org.apache.qpid.jms.util.IdGenerator;
import org.apache.qpid.jms.util.PropertyUtil;
import org.apache.qpid.jms.util.URISupport;
import org.apache.qpid.jms.util.URISupport.CompositeData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * JMS ConnectionFactory Implementation.
 */
public class JmsConnectionFactory extends JNDIStorable implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory {

<span class="fc" id="L50">    private static final Logger LOG = LoggerFactory.getLogger(JmsConnectionFactory.class);</span>
    private static final String CLIENT_ID_PROP = &quot;clientID&quot;;

    public static final String REMOTE_URI_PROP = &quot;remoteURI&quot;;

    private URI remoteURI;
    private String username;
    private String password;
    private String clientID;
    private boolean forceAsyncSend;
    private boolean alwaysSyncSend;
    private boolean sendAcksAsync;
    private boolean localMessagePriority;
<span class="pc" id="L63">    private String queuePrefix = null;</span>
<span class="pc" id="L64">    private String topicPrefix = null;</span>
<span class="pc" id="L65">    private boolean validatePropertyNames = true;</span>
<span class="pc" id="L66">    private long sendTimeout = JmsConnectionInfo.DEFAULT_SEND_TIMEOUT;</span>
<span class="pc" id="L67">    private long requestTimeout = JmsConnectionInfo.DEFAULT_REQUEST_TIMEOUT;</span>
<span class="pc" id="L68">    private long closeTimeout = JmsConnectionInfo.DEFAULT_CLOSE_TIMEOUT;</span>
<span class="pc" id="L69">    private long connectTimeout = JmsConnectionInfo.DEFAULT_CONNECT_TIMEOUT;</span>
    private IdGenerator clientIdGenerator;
    private String clientIDPrefix;
    private IdGenerator connectionIdGenerator;
    private String connectionIDPrefix;
    private ExceptionListener exceptionListener;

<span class="pc" id="L76">    private JmsPrefetchPolicy prefetchPolicy = new JmsPrefetchPolicy();</span>
<span class="pc" id="L77">    private JmsRedeliveryPolicy redeliveryPolicy = new JmsRedeliveryPolicy();</span>

<span class="fc" id="L79">    public JmsConnectionFactory() {</span>
<span class="fc" id="L80">    }</span>

<span class="fc" id="L82">    public JmsConnectionFactory(String username, String password) {</span>
<span class="fc" id="L83">        setUsername(username);</span>
<span class="fc" id="L84">        setPassword(password);</span>
<span class="fc" id="L85">    }</span>

    public JmsConnectionFactory(String remoteURI) {
<span class="fc" id="L88">        this(createURI(remoteURI));</span>
<span class="fc" id="L89">    }</span>

<span class="fc" id="L91">    public JmsConnectionFactory(URI remoteURI) {</span>
<span class="fc" id="L92">        setRemoteURI(remoteURI.toString());</span>
<span class="fc" id="L93">    }</span>

<span class="nc" id="L95">    public JmsConnectionFactory(String userName, String password, URI remoteURI) {</span>
<span class="nc" id="L96">        setUsername(userName);</span>
<span class="nc" id="L97">        setPassword(password);</span>
<span class="nc" id="L98">        setRemoteURI(remoteURI.toString());</span>
<span class="nc" id="L99">    }</span>

<span class="fc" id="L101">    public JmsConnectionFactory(String userName, String password, String remoteURI) {</span>
<span class="fc" id="L102">        setUsername(userName);</span>
<span class="fc" id="L103">        setPassword(password);</span>
<span class="fc" id="L104">        setRemoteURI(remoteURI);</span>
<span class="fc" id="L105">    }</span>

    @Override
    protected Map&lt;String, String&gt; buildFromProperties(Map&lt;String, String&gt; props) {
        // Apply the remoteURI in a consistent order before
        // any other properties, since as it may contain
        // some options within it.
<span class="fc" id="L112">        String remoteURI = props.remove(REMOTE_URI_PROP);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (remoteURI != null) {</span>
<span class="fc" id="L114">            setRemoteURI(remoteURI);</span>
        }

<span class="fc" id="L117">        return PropertyUtil.setProperties(this, props);</span>
    }

    @Override
    protected void populateProperties(Map&lt;String, String&gt; props) {
        try {
<span class="fc" id="L123">            Map&lt;String, String&gt; result = PropertyUtil.getProperties(this);</span>
<span class="fc" id="L124">            props.putAll(result);</span>
<span class="nc" id="L125">        } catch (Exception e) {</span>
<span class="nc" id="L126">            e.printStackTrace();</span>
<span class="fc" id="L127">        }</span>
<span class="fc" id="L128">    }</span>

    /**
     * @return a TopicConnection
     * @throws JMSException
     * @see javax.jms.TopicConnectionFactory#createTopicConnection()
     */
    @Override
    public TopicConnection createTopicConnection() throws JMSException {
<span class="nc" id="L137">        return createTopicConnection(getUsername(), getPassword());</span>
    }

    /**
     * @param username
     * @param password
     * @return a TopicConnection
     * @throws JMSException
     * @see javax.jms.TopicConnectionFactory#createTopicConnection(java.lang.String,
     *      java.lang.String)
     */
    @Override
    public TopicConnection createTopicConnection(String username, String password) throws JMSException {
        try {
<span class="nc" id="L151">            String connectionId = getConnectionIdGenerator().generateId();</span>
<span class="nc" id="L152">            Provider provider = createProvider(remoteURI);</span>
<span class="nc" id="L153">            JmsTopicConnection result = new JmsTopicConnection(connectionId, provider, getClientIdGenerator());</span>
<span class="nc" id="L154">            return configureConnection(result, username, password);</span>
<span class="nc" id="L155">        } catch (Exception e) {</span>
<span class="nc" id="L156">            throw JmsExceptionSupport.create(e);</span>
        }
    }

    /**
     * @return a Connection
     * @throws JMSException
     * @see javax.jms.ConnectionFactory#createConnection()
     */
    @Override
    public Connection createConnection() throws JMSException {
<span class="fc" id="L167">        return createConnection(getUsername(), getPassword());</span>
    }

    /**
     * @param username
     * @param password
     * @return Connection
     * @throws JMSException
     * @see javax.jms.ConnectionFactory#createConnection(java.lang.String, java.lang.String)
     */
    @Override
    public Connection createConnection(String username, String password) throws JMSException {
        try {
<span class="fc" id="L180">            String connectionId = getConnectionIdGenerator().generateId();</span>
<span class="fc" id="L181">            Provider provider = createProvider(remoteURI);</span>
<span class="fc" id="L182">            JmsConnection result = new JmsConnection(connectionId, provider, getClientIdGenerator());</span>
<span class="fc" id="L183">            return configureConnection(result, username, password);</span>
<span class="fc" id="L184">        } catch (Exception e) {</span>
<span class="fc" id="L185">            throw JmsExceptionSupport.create(&quot;Failed to create connection to: &quot; + getRemoteURI(), e);</span>
        }
    }

    /**
     * @return a QueueConnection
     * @throws JMSException
     * @see javax.jms.QueueConnectionFactory#createQueueConnection()
     */
    @Override
    public QueueConnection createQueueConnection() throws JMSException {
<span class="nc" id="L196">        return createQueueConnection(getUsername(), getPassword());</span>
    }

    /**
     * @param username
     * @param password
     * @return a QueueConnection
     * @throws JMSException
     * @see javax.jms.QueueConnectionFactory#createQueueConnection(java.lang.String,
     *      java.lang.String)
     */
    @Override
    public QueueConnection createQueueConnection(String username, String password) throws JMSException {
        try {
<span class="nc" id="L210">            String connectionId = getConnectionIdGenerator().generateId();</span>
<span class="nc" id="L211">            Provider provider = createProvider(remoteURI);</span>
<span class="nc" id="L212">            JmsQueueConnection result = new JmsQueueConnection(connectionId, provider, getClientIdGenerator());</span>
<span class="nc" id="L213">            return configureConnection(result, username, password);</span>
<span class="nc" id="L214">        } catch (Exception e) {</span>
<span class="nc" id="L215">            throw JmsExceptionSupport.create(e);</span>
        }
    }

    protected &lt;T extends JmsConnection&gt; T configureConnection(T connection, String username, String password) throws JMSException {
        try {

<span class="fc" id="L222">            Map&lt;String, String&gt; properties = PropertyUtil.getProperties(this);</span>
            // We must ensure that we apply the clientID last, since setting it on
            // the Connection object provokes establishing the underlying connection.
<span class="fc" id="L225">            boolean setClientID = false;</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (properties.containsKey(CLIENT_ID_PROP)) {</span>
<span class="fc" id="L227">                setClientID = true;</span>
<span class="fc" id="L228">                properties.remove(CLIENT_ID_PROP);</span>
            }

<span class="fc" id="L231">            PropertyUtil.setProperties(connection, properties);</span>
<span class="fc" id="L232">            connection.setExceptionListener(exceptionListener);</span>
<span class="fc" id="L233">            connection.setUsername(username);</span>
<span class="fc" id="L234">            connection.setPassword(password);</span>
<span class="fc" id="L235">            connection.setConfiguredURI(remoteURI);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (setClientID){</span>
<span class="fc" id="L237">                connection.setClientID(clientID);</span>
            }

<span class="fc" id="L240">            return connection;</span>
<span class="fc" id="L241">        } catch (Exception e) {</span>
<span class="fc" id="L242">            throw JmsExceptionSupport.create(e);</span>
        }
    }

    protected Provider createProvider(URI remoteURI) throws Exception {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if(remoteURI == null) {</span>
<span class="fc" id="L248">            throw new IllegalStateException(&quot;No remoteURI has been provided&quot;);</span>
        }

<span class="fc" id="L251">        Provider result = null;</span>

        try {
<span class="fc" id="L254">            result = ProviderFactory.create(remoteURI);</span>
<span class="fc" id="L255">            result.connect();</span>
<span class="fc" id="L256">        } catch (Exception ex) {</span>
<span class="fc" id="L257">            LOG.error(&quot;Failed to create JMS Provider instance for: {}&quot;, remoteURI.getScheme());</span>
<span class="fc" id="L258">            LOG.trace(&quot;Error: &quot;, ex);</span>
<span class="fc" id="L259">            throw ex;</span>
<span class="fc" id="L260">        }</span>

<span class="fc" id="L262">        return result;</span>
    }

    protected static URI createURI(String name) {
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">        if (name != null &amp;&amp; name.trim().isEmpty() == false) {</span>
            try {
<span class="fc" id="L268">                return new URI(name);</span>
<span class="nc" id="L269">            } catch (URISyntaxException e) {</span>
<span class="nc" id="L270">                throw (IllegalArgumentException) new IllegalArgumentException(&quot;Invalid remote URI: &quot; + name).initCause(e);</span>
            }
        }
<span class="nc" id="L273">        return null;</span>
    }

    protected synchronized IdGenerator getConnectionIdGenerator() {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        if (connectionIdGenerator == null) {</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (connectionIDPrefix != null) {</span>
<span class="nc" id="L279">                connectionIdGenerator = new IdGenerator(connectionIDPrefix);</span>
            } else {
<span class="fc" id="L281">                connectionIdGenerator = new IdGenerator();</span>
            }
        }
<span class="fc" id="L284">        return connectionIdGenerator;</span>
    }

    protected synchronized void setConnectionIdGenerator(IdGenerator connectionIdGenerator) {
<span class="nc" id="L288">        this.connectionIdGenerator = connectionIdGenerator;</span>
<span class="nc" id="L289">    }</span>

    //////////////////////////////////////////////////////////////////////////
    // Property getters and setters
    //////////////////////////////////////////////////////////////////////////

    /**
     * @return the remoteURI
     */
    public String getRemoteURI() {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        return this.remoteURI != null ? this.remoteURI.toString() : &quot;&quot;;</span>
    }

    /**
     * @param remoteURI
     *        the remoteURI to set
     */
    public void setRemoteURI(String remoteURI) {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (remoteURI == null) {</span>
<span class="nc" id="L308">            throw new IllegalArgumentException(&quot;remoteURI cannot be null&quot;);</span>
        }
<span class="fc" id="L310">        this.remoteURI = createURI(remoteURI);</span>

        try {
<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (this.remoteURI.getQuery() != null) {</span>
<span class="fc" id="L314">                Map&lt;String, String&gt; map = PropertyUtil.parseQuery(this.remoteURI.getQuery());</span>
<span class="fc" id="L315">                Map&lt;String, String&gt; jmsOptionsMap = PropertyUtil.filterProperties(map, &quot;jms.&quot;);</span>

<span class="fc" id="L317">                Map&lt;String, String&gt; unused = PropertyUtil.setProperties(this, jmsOptionsMap);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                if (!unused.isEmpty()) {</span>
<span class="fc" id="L319">                    String msg = &quot;&quot;</span>
                        + &quot; Not all jms options could be set on the ConnectionFactory.&quot;
                        + &quot; Check the options are spelled correctly.&quot;
                        + &quot; Unused parameters=[&quot; + unused + &quot;].&quot;
                        + &quot; This connection factory cannot be started.&quot;;
<span class="fc" id="L324">                    throw new IllegalArgumentException(msg);</span>
                } else {
<span class="fc" id="L326">                    this.remoteURI = PropertyUtil.replaceQuery(this.remoteURI, map);</span>
                }
<span class="fc bfc" id="L328" title="All 2 branches covered.">            } else if (URISupport.isCompositeURI(this.remoteURI)) {</span>
<span class="fc" id="L329">                CompositeData data = URISupport.parseComposite(this.remoteURI);</span>
<span class="fc" id="L330">                Map&lt;String, String&gt; jmsOptionsMap = PropertyUtil.filterProperties(data.getParameters(), &quot;jms.&quot;);</span>
<span class="fc" id="L331">                Map&lt;String, String&gt; unused = PropertyUtil.setProperties(this, jmsOptionsMap);</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">                if (!unused.isEmpty()) {</span>
<span class="nc" id="L333">                    String msg = &quot;&quot;</span>
                        + &quot; Not all jms options could be set on the ConnectionFactory.&quot;
                        + &quot; Check the options are spelled correctly.&quot;
                        + &quot; Unused parameters=[&quot; + unused + &quot;].&quot;
                        + &quot; This connection factory cannot be started.&quot;;
<span class="nc" id="L338">                    throw new IllegalArgumentException(msg);</span>
                } else {
<span class="fc" id="L340">                    this.remoteURI = data.toURI();</span>
                }
            }
<span class="fc" id="L343">        } catch (Exception e) {</span>
<span class="fc" id="L344">            throw new IllegalArgumentException(e.getMessage());</span>
<span class="fc" id="L345">        }</span>
<span class="fc" id="L346">    }</span>

    /**
     * @return the username
     */
    public String getUsername() {
<span class="fc" id="L352">        return this.username;</span>
    }

    /**
     * @param username
     *        the username to set
     */
    public void setUsername(String username) {
<span class="fc" id="L360">        this.username = username;</span>
<span class="fc" id="L361">    }</span>

    /**
     * @return the password
     */
    public String getPassword() {
<span class="fc" id="L367">        return this.password;</span>
    }

    /**
     * @param password
     *        the password to set
     */
    public void setPassword(String password) {
<span class="fc" id="L375">        this.password = password;</span>
<span class="fc" id="L376">    }</span>

    public boolean isForceAsyncSend() {
<span class="fc" id="L379">        return forceAsyncSend;</span>
    }

    public void setForceAsyncSend(boolean forceAsyncSend) {
<span class="fc" id="L383">        this.forceAsyncSend = forceAsyncSend;</span>
<span class="fc" id="L384">    }</span>

    /**
     * @return the localMessagePriority configuration option.
     */
    public boolean isLocalMessagePriority() {
<span class="fc" id="L390">        return this.localMessagePriority;</span>
    }

    /**
     * Enables client-side message priority support in MessageConsumer instances.
     * This results in all prefetched messages being dispatched in priority order.
     *
     * @param localMessagePriority the messagePrioritySupported to set
     */
    public void setLocalMessagePriority(boolean localMessagePriority) {
<span class="fc" id="L400">        this.localMessagePriority = localMessagePriority;</span>
<span class="fc" id="L401">    }</span>

    /**
     * Returns the prefix applied to Queues that are created by the client.
     *
     * @return the currently configured Queue prefix.
     */
    public String getQueuePrefix() {
<span class="fc" id="L409">        return queuePrefix;</span>
    }

    public void setQueuePrefix(String queuePrefix) {
<span class="fc" id="L413">        this.queuePrefix = queuePrefix;</span>
<span class="fc" id="L414">    }</span>

    /**
     * Returns the prefix applied to Topics that are created by the client.
     *
     * @return the currently configured Topic prefix.
     */
    public String getTopicPrefix() {
<span class="fc" id="L422">        return topicPrefix;</span>
    }

    public void setTopicPrefix(String topicPrefix) {
<span class="fc" id="L426">        this.topicPrefix = topicPrefix;</span>
<span class="fc" id="L427">    }</span>

    public boolean isValidatePropertyNames() {
<span class="fc" id="L430">        return validatePropertyNames;</span>
    }

    public void setValidatePropertyNames(boolean validatePropertyNames) {
<span class="fc" id="L434">        this.validatePropertyNames = validatePropertyNames;</span>
<span class="fc" id="L435">    }</span>

    /**
     * Gets the currently set close timeout.
     *
     * @return the currently set close timeout.
     */
    public long getCloseTimeout() {
<span class="fc" id="L443">        return closeTimeout;</span>
    }

    /**
     * Sets the close timeout used to control how long a Connection close will wait for
     * clean shutdown of the connection before giving up.  A negative value means wait
     * forever.
     *
     * Care should be taken in that a very short close timeout can cause the client to
     * not cleanly shutdown the connection and it's resources.
     *
     * @param closeTimeout
     *        time in milliseconds to wait for a clean connection close.
     */
    public void setCloseTimeout(long closeTimeout) {
<span class="fc" id="L458">        this.closeTimeout = closeTimeout;</span>
<span class="fc" id="L459">    }</span>

    /**
     * Returns the currently configured wire level connect timeout.
     *
     * @return the currently configured wire level connect timeout.
     */
    public long getConnectTimeout() {
<span class="fc" id="L467">        return this.connectTimeout;</span>
    }

    /**
     * Sets the timeout value used to control how long a client will wait for a successful
     * connection to the remote peer to be established before considering the attempt to
     * have failed.  This value does not control socket level connection timeout but rather
     * connection handshake at the wire level, to control the socket level timeouts use the
     * standard socket options configuration values.
     *
     * @param connectTimeout
     *        the time in milliseconds to wait for the protocol connection handshake to complete.
     */
    public void setConnectTimeout(long connectTimeout) {
<span class="fc" id="L481">        this.connectTimeout = connectTimeout;</span>
<span class="fc" id="L482">    }</span>

    public long getSendTimeout() {
<span class="fc" id="L485">        return sendTimeout;</span>
    }

    public void setSendTimeout(long sendTimeout) {
<span class="fc" id="L489">        this.sendTimeout = sendTimeout;</span>
<span class="fc" id="L490">    }</span>

    public long getRequestTimeout() {
<span class="fc" id="L493">        return requestTimeout;</span>
    }

    public void setRequestTimeout(long requestTimeout) {
<span class="fc" id="L497">        this.requestTimeout = requestTimeout;</span>
<span class="fc" id="L498">    }</span>

    public JmsPrefetchPolicy getPrefetchPolicy() {
<span class="fc" id="L501">        return prefetchPolicy;</span>
    }

    public void setPrefetchPolicy(JmsPrefetchPolicy prefetchPolicy) {
<span class="nc" id="L505">        this.prefetchPolicy = prefetchPolicy;</span>
<span class="nc" id="L506">    }</span>

    /**
     * Returns the JmsRedeliveryPolicy that is applied when a new connection is created.
     *
     * @return the redeliveryPolicy that is currently configured for this factory.
     */
    public JmsRedeliveryPolicy getRedeliveryPolicy() {
<span class="fc" id="L514">        return redeliveryPolicy;</span>
    }

    /**
     * Sets the JmsRedeliveryPolicy that is applied when a new connection is created.
     *
     * @param redeliveryPolicy
     *        The new redeliveryPolicy to set
     */
    public void setRedeliveryPolicy(JmsRedeliveryPolicy redeliveryPolicy) {
<span class="nc" id="L524">        this.redeliveryPolicy = redeliveryPolicy;</span>
<span class="nc" id="L525">    }</span>

    /**
     * @return the currently configured client ID prefix for auto-generated client IDs.
     */
    public synchronized String getClientIDPrefix() {
<span class="fc" id="L531">        return clientIDPrefix;</span>
    }

    /**
     * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS
     * client does not explicitly specify one.
     *
     * @param clientIDPrefix
     *        the value to use as a prefix on auto-generated client IDs.
     */
    public synchronized void setClientIDPrefix(String clientIDPrefix) {
<span class="nc" id="L542">        this.clientIDPrefix = clientIDPrefix;</span>
<span class="nc" id="L543">    }</span>

    protected synchronized IdGenerator getClientIdGenerator() {
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (clientIdGenerator == null) {</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">            if (clientIDPrefix != null) {</span>
<span class="nc" id="L548">                clientIdGenerator = new IdGenerator(clientIDPrefix);</span>
            } else {
<span class="fc" id="L550">                clientIdGenerator = new IdGenerator();</span>
            }
        }
<span class="fc" id="L553">        return clientIdGenerator;</span>
    }

    protected synchronized void setClientIdGenerator(IdGenerator clientIdGenerator) {
<span class="nc" id="L557">        this.clientIdGenerator = clientIdGenerator;</span>
<span class="nc" id="L558">    }</span>

    public String getClientID() {
<span class="fc" id="L561">        return clientID;</span>
    }

    /**
     * Sets the JMS clientID to use for connections created by this factory.
     *
     * NOTE: A clientID can only be used by one Connection at a time, so setting it here
     * will restrict the ConnectionFactory to creating a single open Connection at a time.
     * It is possible to set the clientID on the Connection itself immediately after
     * creation if no value has been set via the factory that created it, which will
     * allow the factory to create multiple open connections at a time.
     */
    public void setClientID(String clientID) {
<span class="fc" id="L574">        this.clientID = clientID;</span>
<span class="fc" id="L575">    }</span>

    /**
     * Sets the prefix used by connection id generator.
     *
     * @param connectionIDPrefix
     *        The string prefix used on all connection Id's created by this factory.
     */
    public synchronized void setConnectionIDPrefix(String connectionIDPrefix) {
<span class="nc" id="L584">        this.connectionIDPrefix = connectionIDPrefix;</span>
<span class="nc" id="L585">    }</span>

    /**
     * Gets the currently configured JMS ExceptionListener that will be set on all
     * new Connection objects created from this factory.
     *
     * NOTE: the listener object is not saved when serializing the factory.
     *
     * @return the currently configured JMS ExceptionListener.
     */
    public ExceptionListener getExceptionListener() {
<span class="fc" id="L596">        return exceptionListener;</span>
    }

    /**
     * Sets the JMS ExceptionListener that will be set on all new Connection objects
     * created from this factory.
     *
     * @param exceptionListener
     *        the JMS ExceptionListener to apply to new Connection's or null to clear.
     */
    public void setExceptionListener(ExceptionListener exceptionListener) {
<span class="fc" id="L607">        this.exceptionListener = exceptionListener;</span>
<span class="fc" id="L608">    }</span>

    /**
     * Returns true if the client should always send messages using a synchronous
     * send operation regardless of persistence mode, or inside a transaction.
     *
     * @return true if sends should always be done synchronously.
     */
    public boolean isAlwaysSyncSend() {
<span class="fc" id="L617">        return alwaysSyncSend;</span>
    }

    /**
     * Configures whether or not the client will always send messages synchronously or not
     * regardless of other factors that might result in an asynchronous send.
     *
     * @param alwaysSyncSend
     *        if true sends are always done synchronously.
     */
    public void setAlwaysSyncSend(boolean alwaysSyncSend) {
<span class="fc" id="L628">        this.alwaysSyncSend = alwaysSyncSend;</span>
<span class="fc" id="L629">    }</span>

    /**
     * @return true if consumer acknowledgments are sent asynchronously or not.
     */
    public boolean isSendAcksAsync() {
<span class="fc" id="L635">        return sendAcksAsync;</span>
    }

    /**
     * Should the message acknowledgments from a consumer be sent synchronously or
     * asynchronously.  Sending the acknowledgments asynchronously can increase the
     * performance of a consumer but opens up the possibility of a missed message
     * acknowledge should the connection be unstable.
     *
     * @param sendAcksAsync
     *        true to have the client send all message acknowledgments asynchronously.
     */
    public void setSendAcksAsync(boolean sendAcksAsync) {
<span class="fc" id="L648">        this.sendAcksAsync = sendAcksAsync;</span>
<span class="fc" id="L649">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>