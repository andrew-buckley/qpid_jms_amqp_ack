<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JmsMessageConsumer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Client with AMQP acknowledgement</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms</a> &gt; <span class="el_source">JmsMessageConsumer.java</span></div><h1>JmsMessageConsumer.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import javax.jms.IllegalStateException;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageListener;
import javax.jms.Session;

import org.apache.qpid.jms.exceptions.JmsExceptionSupport;
import org.apache.qpid.jms.message.JmsAcknowledgeCallback;
import org.apache.qpid.jms.message.JmsInboundMessageDispatch;
import org.apache.qpid.jms.message.JmsMessage;
import org.apache.qpid.jms.meta.JmsConsumerId;
import org.apache.qpid.jms.meta.JmsConsumerInfo;
import org.apache.qpid.jms.provider.Provider;
import org.apache.qpid.jms.provider.ProviderConstants.ACK_TYPE;
import org.apache.qpid.jms.provider.ProviderFuture;
import org.apache.qpid.jms.util.FifoMessageQueue;
import org.apache.qpid.jms.util.MessageQueue;
import org.apache.qpid.jms.util.PriorityMessageQueue;

/**
 * implementation of a JMS Message Consumer
 */
public class JmsMessageConsumer implements MessageConsumer, JmsMessageAvailableConsumer, JmsMessageDispatcher {

    protected final JmsSession session;
    protected final JmsConnection connection;
    protected JmsConsumerInfo consumerInfo;
    protected final int acknowledgementMode;
<span class="fc" id="L54">    protected final AtomicBoolean closed = new AtomicBoolean();</span>
    protected boolean started;
    protected MessageListener messageListener;
    protected JmsMessageAvailableListener availableListener;
    protected final MessageQueue messageQueue;
<span class="fc" id="L59">    protected final Lock lock = new ReentrantLock();</span>
<span class="fc" id="L60">    protected final AtomicBoolean suspendedConnection = new AtomicBoolean();</span>
<span class="fc" id="L61">    protected final AtomicBoolean delivered = new AtomicBoolean();</span>
    protected Exception failureCause;

    /**
     * Create a non-durable MessageConsumer
     *
     * @param consumerId
     * @param session
     * @param destination
     * @param selector
     * @param noLocal
     * @throws JMSException
     */
    protected JmsMessageConsumer(JmsConsumerId consumerId, JmsSession session, JmsDestination destination,
                                 String selector, boolean noLocal) throws JMSException {
<span class="fc" id="L76">        this(consumerId, session, destination, null, selector, noLocal);</span>
<span class="fc" id="L77">    }</span>

    /**
     * Create a MessageConsumer which could be durable.
     *
     * @param consumerId
     * @param session
     * @param destination
     * @param name
     * @param selector
     * @param noLocal
     * @throws JMSException
     */
    protected JmsMessageConsumer(JmsConsumerId consumerId, JmsSession session, JmsDestination destination,
<span class="fc" id="L91">                                 String name, String selector, boolean noLocal) throws JMSException {</span>
<span class="fc" id="L92">        this.session = session;</span>
<span class="fc" id="L93">        this.connection = session.getConnection();</span>
<span class="fc" id="L94">        this.acknowledgementMode = session.acknowledgementMode();</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">        if(destination.isTemporary()) {</span>
<span class="fc" id="L97">            connection.checkConsumeFromTemporaryDestination((JmsTemporaryDestination) destination);</span>
        }

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (connection.isLocalMessagePriority()) {</span>
<span class="nc" id="L101">            this.messageQueue = new PriorityMessageQueue();</span>
        } else {
<span class="fc" id="L103">            this.messageQueue = new FifoMessageQueue();</span>
        }

<span class="fc" id="L106">        JmsPrefetchPolicy policy = connection.getPrefetchPolicy();</span>
<span class="fc" id="L107">        JmsRedeliveryPolicy redeliveryPolicy = connection.getRedeliveryPolicy().copy();</span>

<span class="fc" id="L109">        consumerInfo = new JmsConsumerInfo(consumerId);</span>
<span class="fc" id="L110">        consumerInfo.setClientId(connection.getClientID());</span>
<span class="fc" id="L111">        consumerInfo.setSelector(selector);</span>
<span class="fc" id="L112">        consumerInfo.setSubscriptionName(name);</span>
<span class="fc" id="L113">        consumerInfo.setDestination(destination);</span>
<span class="fc" id="L114">        consumerInfo.setAcknowledgementMode(acknowledgementMode);</span>
<span class="fc" id="L115">        consumerInfo.setNoLocal(noLocal);</span>
<span class="fc" id="L116">        consumerInfo.setBrowser(isBrowser());</span>
<span class="fc" id="L117">        consumerInfo.setPrefetchSize(getConfiguredPrefetch(destination, policy));</span>
<span class="fc" id="L118">        consumerInfo.setRedeliveryPolicy(redeliveryPolicy);</span>

<span class="fc" id="L120">        session.getConnection().createResource(consumerInfo);</span>
<span class="fc" id="L121">    }</span>

    public void init() throws JMSException {
<span class="fc" id="L124">        session.add(this);</span>
<span class="fc" id="L125">        startConsumerResource();</span>
<span class="fc" id="L126">    }</span>

    private void startConsumerResource() throws JMSException {
        try {
<span class="fc" id="L130">            session.getConnection().startResource(consumerInfo);</span>
<span class="nc" id="L131">        } catch (JMSException ex) {</span>
<span class="nc" id="L132">            session.remove(this);</span>
<span class="nc" id="L133">            throw ex;</span>
<span class="fc" id="L134">        }</span>
<span class="fc" id="L135">    }</span>

    /**
     * @throws JMSException
     * @see javax.jms.MessageConsumer#close()
     */
    @Override
    public void close() throws JMSException {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (!closed.get()) {</span>
<span class="fc" id="L144">            session.getTransactionContext().addSynchronization(new JmsTxSynchronization() {</span>

                @Override
                public boolean validate(JmsTransactionContext context) throws Exception {
<span class="pc bpc" id="L148" title="3 of 4 branches missed.">                    if (!context.isInTransaction() || !delivered.get()) {</span>
<span class="fc" id="L149">                        doClose();</span>
<span class="fc" id="L150">                        return false;</span>
                    }

<span class="nc" id="L153">                    return true;</span>
                }

                @Override
                public void afterCommit() throws Exception {
<span class="nc" id="L158">                    doClose();</span>
<span class="nc" id="L159">                }</span>

                @Override
                public void afterRollback() throws Exception {
<span class="nc" id="L163">                    doClose();</span>
<span class="nc" id="L164">                }</span>
            });
        }
<span class="fc" id="L167">    }</span>

    /**
     * Called to initiate shutdown of Producer resources and request that the remote
     * peer remove the registered producer.
     *
     * @throws JMSException
     */
    protected void doClose() throws JMSException {
<span class="fc" id="L176">        shutdown();</span>
<span class="fc" id="L177">        this.connection.destroyResource(consumerInfo);</span>
<span class="fc" id="L178">    }</span>

    /**
     * Called to release all producer resources without requiring a destroy request
     * to be sent to the remote peer.  This is most commonly needed when the parent
     * Session is closing.
     *
     * @throws JMSException
     */
    protected void shutdown() throws JMSException {
<span class="fc" id="L188">        shutdown(null);</span>
<span class="fc" id="L189">    }</span>

    protected void shutdown(Exception cause) throws JMSException {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (closed.compareAndSet(false, true)) {</span>
<span class="fc" id="L193">            failureCause = cause;</span>
<span class="fc" id="L194">            session.remove(this);</span>
<span class="fc" id="L195">            stop(true);</span>
        }
<span class="fc" id="L197">    }</span>

    /**
     * @return a Message or null if closed during the operation
     * @throws JMSException
     * @see javax.jms.MessageConsumer#receive()
     */
    @Override
    public Message receive() throws JMSException {
<span class="nc" id="L206">        return receive(0);</span>
    }

    /**
     * @param timeout
     * @return a Message or null
     * @throws JMSException
     * @see javax.jms.MessageConsumer#receive(long)
     */
    @Override
    public Message receive(long timeout) throws JMSException {
<span class="fc" id="L217">        checkClosed();</span>
<span class="fc" id="L218">        checkMessageListener();</span>
<span class="fc" id="L219">        sendPullCommand(timeout);</span>

<span class="fc" id="L221">        long wait = timeout;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (timeout == 0) {</span>
<span class="fc" id="L223">            wait = -1;</span>
        }

        try {
<span class="fc" id="L227">            return copy(ackFromReceive(this.messageQueue.dequeue(wait)));</span>
<span class="nc" id="L228">        } catch (InterruptedException e) {</span>
<span class="nc" id="L229">            throw JmsExceptionSupport.create(e);</span>
        }
    }

    /**
     * @return a Message or null
     * @throws JMSException
     * @see javax.jms.MessageConsumer#receiveNoWait()
     */
    @Override
    public Message receiveNoWait() throws JMSException {
<span class="nc" id="L240">        checkClosed();</span>
<span class="nc" id="L241">        checkMessageListener();</span>
<span class="nc" id="L242">        sendPullCommand(-1);</span>

<span class="nc" id="L244">        return copy(ackFromReceive(this.messageQueue.dequeueNoWait()));</span>
    }

    protected void checkClosed() throws IllegalStateException {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (closed.get()) {</span>
<span class="fc" id="L249">            IllegalStateException jmsEx = null;</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (failureCause == null) {</span>
<span class="fc" id="L252">                jmsEx = new IllegalStateException(&quot;The MessageConsumer is closed&quot;);</span>
            } else {
<span class="fc" id="L254">                jmsEx = new IllegalStateException(&quot;The MessageConsumer was closed due to an unrecoverable error.&quot;);</span>
<span class="fc" id="L255">                jmsEx.initCause(failureCause);</span>
            }

<span class="fc" id="L258">            throw jmsEx;</span>
        }
<span class="fc" id="L260">    }</span>

    JmsMessage copy(final JmsInboundMessageDispatch envelope) throws JMSException {
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">        if (envelope == null || envelope.getMessage() == null) {</span>
<span class="nc" id="L264">            return null;</span>
        }
<span class="fc" id="L266">        return envelope.getMessage().copy();</span>
    }

    JmsInboundMessageDispatch ackFromReceive(final JmsInboundMessageDispatch envelope) throws JMSException {
<span class="pc bpc" id="L270" title="2 of 4 branches missed.">        if (envelope != null &amp;&amp; envelope.getMessage() != null) {</span>
<span class="fc" id="L271">            JmsMessage message = envelope.getMessage();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (message.getAcknowledgeCallback() != null) {</span>
                // Message has been received by the app.. expand the credit
                // window so that we receive more messages.
<span class="fc" id="L275">                doAckDelivered(envelope);</span>
            } else {
<span class="fc" id="L277">                doAckConsumed(envelope);</span>
            }

            // Tags that we have delivered and can't close if in a TX Session.
<span class="fc" id="L281">            delivered.set(true);</span>
        }
<span class="fc" id="L283">        return envelope;</span>
    }

    private JmsInboundMessageDispatch doAckConsumed(final JmsInboundMessageDispatch envelope) throws JMSException {
<span class="fc" id="L287">        checkClosed();</span>
        try {
<span class="fc" id="L289">            session.acknowledge(envelope, ACK_TYPE.CONSUMED);</span>
<span class="nc" id="L290">        } catch (JMSException ex) {</span>
<span class="nc" id="L291">            session.onException(ex);</span>
<span class="nc" id="L292">            throw ex;</span>
<span class="fc" id="L293">        }</span>
<span class="fc" id="L294">        return envelope;</span>
    }

    private JmsInboundMessageDispatch doAckDelivered(final JmsInboundMessageDispatch envelope) throws JMSException {
        try {
<span class="fc" id="L299">            session.acknowledge(envelope, ACK_TYPE.DELIVERED);</span>
<span class="nc" id="L300">        } catch (JMSException ex) {</span>
<span class="nc" id="L301">            session.onException(ex);</span>
<span class="nc" id="L302">            throw ex;</span>
<span class="fc" id="L303">        }</span>
<span class="fc" id="L304">        return envelope;</span>
    }

    private void doAckReleased(final JmsInboundMessageDispatch envelope) throws JMSException {
        try {
<span class="fc" id="L309">            session.acknowledge(envelope, ACK_TYPE.RELEASED);</span>
<span class="nc" id="L310">        } catch (JMSException ex) {</span>
<span class="nc" id="L311">            session.onException(ex);</span>
<span class="nc" id="L312">            throw ex;</span>
<span class="fc" id="L313">        }</span>
<span class="fc" id="L314">    }</span>

    /**
     * Called from the session when a new Message has been dispatched to this Consumer
     * from the connection.
     *
     * @param envelope
     *        the newly arrived message.
     */
    @Override
    public void onInboundMessage(final JmsInboundMessageDispatch envelope) {
<span class="fc" id="L325">        lock.lock();</span>
        try {
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (acknowledgementMode == Session.CLIENT_ACKNOWLEDGE) {</span>
<span class="fc" id="L328">                envelope.getMessage().setAcknowledgeCallback(new JmsAcknowledgeCallback() {</span>
                    @Override
                    public void call(ACK_TYPE ackType) throws JMSException {
<span class="nc bnc" id="L331" title="All 2 branches missed.">                        if (session.isClosed()) {</span>
<span class="nc" id="L332">                            throw new javax.jms.IllegalStateException(&quot;Session closed.&quot;);</span>
                        }
<span class="nc" id="L334">                        session.acknowledge(ackType);</span>
<span class="nc" id="L335">                        envelope.getMessage().setAcknowledgeCallback(null);</span>
<span class="nc" id="L336">                    }</span>
                });
            }

<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if (envelope.isEnqueueFirst()) {</span>
<span class="nc" id="L341">                this.messageQueue.enqueueFirst(envelope);</span>
            } else {
<span class="fc" id="L343">                this.messageQueue.enqueue(envelope);</span>
            }

<span class="pc bpc" id="L346" title="3 of 4 branches missed.">            if (this.messageListener != null &amp;&amp; this.started) {</span>
<span class="nc" id="L347">                session.getExecutor().execute(new MessageDeliverTask());</span>
            } else {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                if (availableListener != null) {</span>
<span class="nc" id="L350">                    session.getExecutor().execute(new Runnable() {</span>
                        @Override
                        public void run() {
<span class="nc bnc" id="L353" title="All 2 branches missed.">                            if (session.isStarted()) {</span>
<span class="nc" id="L354">                                availableListener.onMessageAvailable(JmsMessageConsumer.this);</span>
                            }
<span class="nc" id="L356">                        }</span>
                    });
                }
            }
        } finally {
<span class="pc" id="L361">            lock.unlock();</span>
<span class="fc" id="L362">        }</span>
<span class="fc" id="L363">    }</span>

    public void start() {
<span class="fc" id="L366">        lock.lock();</span>
        try {
<span class="fc" id="L368">            this.started = true;</span>
<span class="fc" id="L369">            this.messageQueue.start();</span>
<span class="fc" id="L370">            drainMessageQueueToListener();</span>
        } finally {
<span class="pc" id="L372">            lock.unlock();</span>
<span class="fc" id="L373">        }</span>
<span class="fc" id="L374">    }</span>

    public void stop() {
<span class="fc" id="L377">        stop(false);</span>
<span class="fc" id="L378">    }</span>

    private void stop(boolean closeMessageQueue) {
<span class="fc" id="L381">        lock.lock();</span>
        try {
<span class="fc" id="L383">            this.started = false;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (closeMessageQueue) {</span>
<span class="fc" id="L385">                this.messageQueue.close();</span>
            } else {
<span class="fc" id="L387">                this.messageQueue.stop();</span>
            }
        } finally {
<span class="pc" id="L390">            lock.unlock();</span>
<span class="fc" id="L391">        }</span>
<span class="fc" id="L392">    }</span>

    void suspendForRollback() throws JMSException {
<span class="fc" id="L395">        stop();</span>

<span class="fc" id="L397">        session.getConnection().stopResource(consumerInfo);</span>
<span class="fc" id="L398">    }</span>

    void resumeAfterRollback() throws JMSException {
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (!this.messageQueue.isEmpty()) {</span>
<span class="fc" id="L402">            List&lt;JmsInboundMessageDispatch&gt; drain = this.messageQueue.removeAll();</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            for (JmsInboundMessageDispatch envelope : drain) {</span>
<span class="fc" id="L404">                doAckReleased(envelope);</span>
<span class="fc" id="L405">            }</span>
<span class="fc" id="L406">            drain.clear();</span>
        }

<span class="fc" id="L409">        start();</span>

<span class="fc" id="L411">        startConsumerResource();</span>
<span class="fc" id="L412">    }</span>

    void drainMessageQueueToListener() {
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">        if (this.messageListener != null &amp;&amp; this.started) {</span>
<span class="nc" id="L416">            session.getExecutor().execute(new MessageDeliverTask());</span>
        }
<span class="fc" id="L418">    }</span>

    /**
     * @return the id
     */
    public JmsConsumerId getConsumerId() {
<span class="fc" id="L424">        return this.consumerInfo.getConsumerId();</span>
    }

    /**
     * @return the Destination
     */
    public JmsDestination getDestination() {
<span class="fc" id="L431">        return this.consumerInfo.getDestination();</span>
    }

    @Override
    public MessageListener getMessageListener() throws JMSException {
<span class="fc" id="L436">        checkClosed();</span>
<span class="fc" id="L437">        return this.messageListener;</span>
    }

    /**
     * @param listener
     * @throws JMSException
     * @see javax.jms.MessageConsumer#setMessageListener(javax.jms.MessageListener)
     */
    @Override
    public void setMessageListener(MessageListener listener) throws JMSException {
<span class="fc" id="L447">        checkClosed();</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (consumerInfo.getPrefetchSize() == 0) {</span>
<span class="nc" id="L449">            throw new JMSException(&quot;Illegal prefetch size of zero. This setting is not supported&quot; +</span>
                                   &quot;for asynchronous consumers please set a value of at least 1&quot;);
        }
<span class="fc" id="L452">        this.messageListener = listener;</span>
<span class="fc" id="L453">        drainMessageQueueToListener();</span>
<span class="fc" id="L454">    }</span>

    /**
     * @return the Message Selector
     * @throws JMSException
     * @see javax.jms.MessageConsumer#getMessageSelector()
     */
    @Override
    public String getMessageSelector() throws JMSException {
<span class="fc" id="L463">        checkClosed();</span>
<span class="fc" id="L464">        return this.consumerInfo.getSelector();</span>
    }

    /**
     * Gets the configured prefetch size for this consumer.
     * @return the prefetch size configuration for this consumer.
     */
    public int getPrefetchSize() {
<span class="fc" id="L472">        return this.consumerInfo.getPrefetchSize();</span>
    }

    protected void checkMessageListener() throws JMSException {
<span class="fc" id="L476">        session.checkMessageListener();</span>
<span class="fc" id="L477">    }</span>

    boolean hasMessageListener() {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        return this.messageListener != null;</span>
    }

    boolean isUsingDestination(JmsDestination destination) {
<span class="nc" id="L484">        return this.consumerInfo.getDestination().equals(destination);</span>
    }

    protected int getMessageQueueSize() {
<span class="nc" id="L488">        return this.messageQueue.size();</span>
    }

    protected boolean isNoLocal() {
<span class="fc" id="L492">        return this.consumerInfo.isNoLocal();</span>
    }

    public boolean isDurableSubscription() {
<span class="fc" id="L496">        return false;</span>
    }

    public boolean isBrowser() {
<span class="fc" id="L500">        return false;</span>
    }

    @Override
    public void setAvailableListener(JmsMessageAvailableListener availableListener) {
<span class="nc" id="L505">        this.availableListener = availableListener;</span>
<span class="nc" id="L506">    }</span>

    @Override
    public JmsMessageAvailableListener getAvailableListener() {
<span class="nc" id="L510">        return availableListener;</span>
    }

    protected void onConnectionInterrupted() {
<span class="fc" id="L514">        messageQueue.clear();</span>
<span class="fc" id="L515">    }</span>

    protected void onConnectionRecovery(Provider provider) throws Exception {
<span class="nc" id="L518">        ProviderFuture request = new ProviderFuture();</span>
<span class="nc" id="L519">        provider.create(consumerInfo, request);</span>
<span class="nc" id="L520">        request.sync();</span>
<span class="nc" id="L521">    }</span>

    protected void onConnectionRecovered(Provider provider) throws Exception {
<span class="nc" id="L524">        ProviderFuture request = new ProviderFuture();</span>
<span class="nc" id="L525">        provider.start(consumerInfo, request);</span>
<span class="nc" id="L526">        request.sync();</span>
<span class="nc" id="L527">    }</span>

    protected void onConnectionRestored() {
<span class="nc" id="L530">    }</span>

    /**
     * Triggers a pull request from the connected Provider.  An attempt is made to set
     * a timeout on the pull request however some providers will not honor this value
     * and the pull will remain active until a message is dispatched.
     * &lt;p&gt;
     * The timeout value can be one of:
     * &lt;br&gt;
     * {@literal &lt; 0} to indicate that the request should expire immediately if no message.&lt;br&gt;
     * {@literal = 0} to indicate that the request should never time out.&lt;br&gt;
     * {@literal &gt; 1} to indicate that the request should expire after the given time in milliseconds.
     *
     * @param timeout
     *        The amount of time the pull request should remain valid.
     */
    protected void sendPullCommand(long timeout) throws JMSException {
<span class="pc bpc" id="L547" title="2 of 6 branches missed.">        if (messageQueue.isEmpty() &amp;&amp; (getPrefetchSize() == 0 || isBrowser())) {</span>
<span class="nc" id="L548">            connection.pull(getConsumerId(), timeout);</span>
        }
<span class="fc" id="L550">    }</span>

    private int getConfiguredPrefetch(JmsDestination destination, JmsPrefetchPolicy policy) {
<span class="fc" id="L553">        int prefetch = 0;</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (destination.isTopic()) {</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (isDurableSubscription()) {</span>
<span class="fc" id="L556">                prefetch = policy.getDurableTopicPrefetch();</span>
            } else {
<span class="fc" id="L558">                prefetch = policy.getTopicPrefetch();</span>
            }
        } else {
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">            if (isBrowser()) {</span>
<span class="nc" id="L562">                prefetch = policy.getQueueBrowserPrefetch();</span>
            } else {
<span class="fc" id="L564">                prefetch = policy.getQueuePrefetch();</span>
            }
        }

<span class="fc" id="L568">        return prefetch;</span>
    }

<span class="nc" id="L571">    private final class MessageDeliverTask implements Runnable {</span>
        @Override
        public void run() {
            JmsInboundMessageDispatch envelope;
<span class="nc bnc" id="L575" title="All 4 branches missed.">            while (session.isStarted() &amp;&amp; (envelope = messageQueue.dequeueNoWait()) != null) {</span>
                try {
<span class="nc" id="L577">                    JmsMessage copy = null;</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">                    boolean autoAckOrDupsOk = acknowledgementMode == Session.AUTO_ACKNOWLEDGE ||</span>
                                              acknowledgementMode == Session.DUPS_OK_ACKNOWLEDGE;
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (autoAckOrDupsOk) {</span>
<span class="nc" id="L581">                        copy = copy(doAckDelivered(envelope));</span>
                    } else {
<span class="nc" id="L583">                        copy = copy(ackFromReceive(envelope));</span>
                    }
<span class="nc" id="L585">                    session.clearSessionRecovered();</span>

<span class="nc" id="L587">                    messageListener.onMessage(copy);</span>

<span class="nc bnc" id="L589" title="All 4 branches missed.">                    if (autoAckOrDupsOk &amp;&amp; !session.isSessionRecovered()) {</span>
<span class="nc" id="L590">                        doAckConsumed(envelope);</span>
                    }
<span class="nc" id="L592">                } catch (Exception e) {</span>
                    // TODO - We need to handle exception of on message with some other
                    //        ack such as rejected and consider adding a redlivery policy
                    //        to control when we might just poison the message with an ack
                    //        of modified set to not deliverable here.
<span class="nc" id="L597">                    session.getConnection().onException(e);</span>
<span class="nc" id="L598">                }</span>
            }
<span class="nc" id="L600">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>