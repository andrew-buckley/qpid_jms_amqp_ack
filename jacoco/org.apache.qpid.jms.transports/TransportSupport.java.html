<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TransportSupport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QpidJMS Client with AMQP acknowledgement</a> &gt; <a href="index.source.html" class="el_package">org.apache.qpid.jms.transports</a> &gt; <span class="el_source">TransportSupport.java</span></div><h1>TransportSupport.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.qpid.jms.transports;

import io.netty.handler.ssl.SslHandler;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509TrustManager;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Static class that provides various utility methods used by Transport implementations.
 */
<span class="nc" id="L50">public class TransportSupport {</span>

<span class="fc" id="L52">    private static final Logger LOG = LoggerFactory.getLogger(TransportSupport.class);</span>

    /**
     * Creates a Netty SslHandler instance for use in Transports that require
     * an SSL encoder / decoder.
     *
     * @param options
     *        The SSL options object to build the SslHandler instance from.
     *
     * @return a new SslHandler that is configured from the given options.
     *
     * @throws Exception if an error occurs while creating the SslHandler instance.
     */
    public static SslHandler createSslHandler(URI remote, TransportSslOptions options) throws Exception {
<span class="fc" id="L66">        return new SslHandler(createSslEngine(remote, createSslContext(options), options));</span>
    }

    /**
     * Create a new SSLContext using the options specific in the given TransportSslOptions
     * instance.
     *
     * @param options
     *        the configured options used to create the SSLContext.
     *
     * @return a new SSLContext instance.
     *
     * @throws Exception if an error occurs while creating the context.
     */
    public static SSLContext createSslContext(TransportSslOptions options) throws Exception {
        try {
<span class="fc" id="L82">            String contextProtocol = options.getContextProtocol();</span>
<span class="fc" id="L83">            LOG.trace(&quot;Getting SSLContext instance using protocol: {}&quot;, contextProtocol);</span>

<span class="fc" id="L85">            SSLContext context = SSLContext.getInstance(contextProtocol);</span>
<span class="fc" id="L86">            KeyManager[] keyMgrs = loadKeyManagers(options);</span>
<span class="fc" id="L87">            TrustManager[] trustManagers = loadTrustManagers(options);</span>

<span class="fc" id="L89">            context.init(keyMgrs, trustManagers, new SecureRandom());</span>
<span class="fc" id="L90">            return context;</span>
<span class="fc" id="L91">        } catch (Exception e) {</span>
<span class="fc" id="L92">            LOG.error(&quot;Failed to create SSLContext: {}&quot;, e, e);</span>
<span class="fc" id="L93">            throw e;</span>
        }
    }

    /**
     * Create a new SSLEngine instance in client mode from the given SSLContext and
     * TransportSslOptions instances.
     *
     * @param context
     *        the SSLContext to use when creating the engine.
     * @param options
     *        the TransportSslOptions to use to configure the new SSLEngine.
     *
     * @return a new SSLEngine instance in client mode.
     *
     * @throws Exception if an error occurs while creating the new SSLEngine.
     */
    public static SSLEngine createSslEngine(SSLContext context, TransportSslOptions options) throws Exception {
<span class="fc" id="L111">        return createSslEngine(null, context, options);</span>
    }

    /**
     * Create a new SSLEngine instance in client mode from the given SSLContext and
     * TransportSslOptions instances.
     *
     * @param remote
     *        the URI of the remote peer that will be used to initialize the engine, may be null if none should.
     * @param context
     *        the SSLContext to use when creating the engine.
     * @param options
     *        the TransportSslOptions to use to configure the new SSLEngine.
     *
     * @return a new SSLEngine instance in client mode.
     *
     * @throws Exception if an error occurs while creating the new SSLEngine.
     */
    public static SSLEngine createSslEngine(URI remote, SSLContext context, TransportSslOptions options) throws Exception {
<span class="fc" id="L130">        SSLEngine engine = null;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if(remote == null) {</span>
<span class="fc" id="L132">            engine = context.createSSLEngine();</span>
        } else {
<span class="fc" id="L134">            engine = context.createSSLEngine(remote.getHost(), remote.getPort());</span>
        }

<span class="fc" id="L137">        engine.setEnabledProtocols(buildEnabledProtocols(engine, options));</span>
<span class="fc" id="L138">        engine.setEnabledCipherSuites(buildEnabledCipherSuites(engine, options));</span>
<span class="fc" id="L139">        engine.setUseClientMode(true);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (options.isVerifyHost()) {</span>
<span class="fc" id="L142">            SSLParameters sslParameters = engine.getSSLParameters();</span>
<span class="fc" id="L143">            sslParameters.setEndpointIdentificationAlgorithm(&quot;HTTPS&quot;);</span>
<span class="fc" id="L144">            engine.setSSLParameters(sslParameters);</span>
        }

<span class="fc" id="L147">        return engine;</span>
    }

    private static String[] buildEnabledProtocols(SSLEngine engine, TransportSslOptions options) {
<span class="fc" id="L151">        List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;();</span>

<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (options.getEnabledProtocols() != null) {</span>
<span class="fc" id="L154">            List&lt;String&gt; configuredProtocols = Arrays.asList(options.getEnabledProtocols());</span>
<span class="fc" id="L155">            LOG.trace(&quot;Configured protocols from transport options: {}&quot;, configuredProtocols);</span>
<span class="fc" id="L156">            enabledProtocols.addAll(configuredProtocols);</span>
<span class="fc" id="L157">        } else {</span>
<span class="fc" id="L158">            List&lt;String&gt; engineProtocols = Arrays.asList(engine.getEnabledProtocols());</span>
<span class="fc" id="L159">            LOG.trace(&quot;Default protocols from the SSLEngine: {}&quot;, engineProtocols);</span>
<span class="fc" id="L160">            enabledProtocols.addAll(engineProtocols);</span>
        }

<span class="fc" id="L163">        String[] disabledProtocols = options.getDisabledProtocols();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (disabledProtocols != null) {</span>
<span class="fc" id="L165">            List&lt;String&gt; disabled = Arrays.asList(disabledProtocols);</span>
<span class="fc" id="L166">            LOG.trace(&quot;Disabled protocols: {}&quot;, disabled);</span>
<span class="fc" id="L167">            enabledProtocols.removeAll(disabled);</span>
        }

<span class="fc" id="L170">        LOG.trace(&quot;Enabled protocols: {}&quot;, enabledProtocols);</span>

<span class="fc" id="L172">        return enabledProtocols.toArray(new String[0]);</span>
    }

    private static String[] buildEnabledCipherSuites(SSLEngine engine, TransportSslOptions options) {
<span class="fc" id="L176">        List&lt;String&gt; enabledCipherSuites = new ArrayList&lt;String&gt;();</span>

<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (options.getEnabledCipherSuites() != null) {</span>
<span class="fc" id="L179">            List&lt;String&gt; configuredCipherSuites = Arrays.asList(options.getEnabledCipherSuites());</span>
<span class="fc" id="L180">            LOG.trace(&quot;Configured cipher suites from transport options: {}&quot;, configuredCipherSuites);</span>
<span class="fc" id="L181">            enabledCipherSuites.addAll(configuredCipherSuites);</span>
<span class="fc" id="L182">        } else {</span>
<span class="fc" id="L183">            List&lt;String&gt; engineCipherSuites = Arrays.asList(engine.getEnabledCipherSuites());</span>
<span class="fc" id="L184">            LOG.trace(&quot;Default cipher suites from the SSLEngine: {}&quot;, engineCipherSuites);</span>
<span class="fc" id="L185">            enabledCipherSuites.addAll(engineCipherSuites);</span>
        }

<span class="fc" id="L188">        String[] disabledCipherSuites = options.getDisabledCipherSuites();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (disabledCipherSuites != null) {</span>
<span class="fc" id="L190">            List&lt;String&gt; disabled = Arrays.asList(disabledCipherSuites);</span>
<span class="fc" id="L191">            LOG.trace(&quot;Disabled cipher suites: {}&quot;, disabled);</span>
<span class="fc" id="L192">            enabledCipherSuites.removeAll(disabled);</span>
        }

<span class="fc" id="L195">        LOG.trace(&quot;Enabled cipher suites: {}&quot;, enabledCipherSuites);</span>

<span class="fc" id="L197">        return enabledCipherSuites.toArray(new String[0]);</span>
    }

    private static TrustManager[] loadTrustManagers(TransportSslOptions options) throws Exception {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (options.isTrustAll()) {</span>
<span class="fc" id="L202">            return new TrustManager[] { createTrustAllTrustManager() };</span>
        }

<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (options.getTrustStoreLocation() == null) {</span>
<span class="fc" id="L206">            return null;</span>
        }

<span class="fc" id="L209">        TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>

<span class="fc" id="L211">        String storeLocation = options.getTrustStoreLocation();</span>
<span class="fc" id="L212">        String storePassword = options.getTrustStorePassword();</span>
<span class="fc" id="L213">        String storeType = options.getStoreType();</span>

<span class="fc" id="L215">        LOG.trace(&quot;Attempt to load TrustStore from location {} of type {}&quot;, storeLocation, storeType);</span>

<span class="fc" id="L217">        KeyStore trustStore = loadStore(storeLocation, storePassword, storeType);</span>
<span class="fc" id="L218">        fact.init(trustStore);</span>

<span class="fc" id="L220">        return fact.getTrustManagers();</span>
    }

    private static KeyManager[] loadKeyManagers(TransportSslOptions options) throws Exception {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (options.getKeyStoreLocation() == null) {</span>
<span class="fc" id="L225">            return null;</span>
        }

<span class="fc" id="L228">        KeyManagerFactory fact = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>

<span class="fc" id="L230">        String storeLocation = options.getKeyStoreLocation();</span>
<span class="fc" id="L231">        String storePassword = options.getKeyStorePassword();</span>
<span class="fc" id="L232">        String storeType = options.getStoreType();</span>
<span class="fc" id="L233">        String alias = options.getKeyAlias();</span>

<span class="fc" id="L235">        LOG.trace(&quot;Attempt to load KeyStore from location {} of type {}&quot;, storeLocation, storeType);</span>

<span class="fc" id="L237">        KeyStore keyStore = loadStore(storeLocation, storePassword, storeType);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        fact.init(keyStore, storePassword != null ? storePassword.toCharArray() : null);</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (alias == null) {</span>
<span class="fc" id="L241">            return fact.getKeyManagers();</span>
        } else {
<span class="fc" id="L243">            validateAlias(keyStore, alias);</span>
<span class="fc" id="L244">            return wrapKeyManagers(alias, fact.getKeyManagers());</span>
        }
    }

    private static KeyManager[] wrapKeyManagers(String alias, KeyManager[] origKeyManagers) {
<span class="fc" id="L249">        KeyManager[] keyManagers = new KeyManager[origKeyManagers.length];</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (int i = 0; i &lt; origKeyManagers.length; i++) {</span>
<span class="fc" id="L251">            KeyManager km = origKeyManagers[i];</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (km instanceof X509ExtendedKeyManager) {</span>
<span class="fc" id="L253">                km = new X509AliasKeyManager(alias, (X509ExtendedKeyManager) km);</span>
            }

<span class="fc" id="L256">            keyManagers[i] = km;</span>
        }

<span class="fc" id="L259">        return keyManagers;</span>
    }

    private static void validateAlias(KeyStore store, String alias) throws IllegalArgumentException, KeyStoreException {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (!store.containsAlias(alias)) {</span>
<span class="fc" id="L264">            throw new IllegalArgumentException(&quot;The alias '&quot; + alias + &quot;' doesn't exist in the key store&quot;);</span>
        }

<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (!store.isKeyEntry(alias)) {</span>
<span class="fc" id="L268">            throw new IllegalArgumentException(&quot;The alias '&quot; + alias + &quot;' in the keystore doesn't represent a key entry&quot;);</span>
        }
<span class="fc" id="L270">    }</span>

    private static KeyStore loadStore(String storePath, final String password, String storeType) throws Exception {
<span class="fc" id="L273">        KeyStore store = KeyStore.getInstance(storeType);</span>
<span class="fc" id="L274">        try (InputStream in = new FileInputStream(new File(storePath));) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">            store.load(in, password != null ? password.toCharArray() : null);</span>
<span class="pc bpc" id="L276" title="4 of 8 branches missed.">        }</span>

<span class="fc" id="L278">        return store;</span>
    }

    private static TrustManager createTrustAllTrustManager() {
<span class="fc" id="L282">        return new X509TrustManager() {</span>
            @Override
            public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
<span class="nc" id="L285">            }</span>

            @Override
            public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
<span class="fc" id="L289">            }</span>

            @Override
            public X509Certificate[] getAcceptedIssuers() {
<span class="fc" id="L293">                return new X509Certificate[0];</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>